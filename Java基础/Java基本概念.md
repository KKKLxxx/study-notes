# Java基本概念

## 一、Java与C++的区别

Java 与 C++ 都是面向对象的语言，都支持继承、封装和多态。但是，它们还是有挺多不相同的地方：

- Java能够进行自动垃圾回收；C++需要手动内存管理
- Java平台无关，可在编译为字节码后在任何JVM上运行，实现“一次编译到处运行”；而C++在不同操作系统需要重新编译再执行，好处是执行更快
- Java只能单继承，但可以实现多个接口；C++支持多继承
- Java没有指针；C++有指针
- Java只有值传递；C++有值传递和引用传递

## 二、JVM、JRE、JDK三者关系

- JVM是Java虚拟机，它负责将Java字节码（由Java编译器生成）解释或编译成机器码，并执行程序。JVM提供了内存管理、垃圾回收、安全性等功能，使得Java程序具备跨平台性
- JRE是Java运行时环境，是Java程序运行所需的最小环境。它包含了JVM和一组Java类库，用于支持Java程序的执行。JRE不包含开发工具，只提供Java程序运行所需的运行环境
- JDK是Java开发工具包，是开发Java程序所需的工具集合。它包含了JRE、编译器（javac）、调试器（jdb）等开发工具，以及一系列的类库（如Java标准库和开发工具库）。JDK提供了开发、编译、调试和运行Java程序所需的全部工具和环境

三者为包含关系：JDK > JRE > JVM

## 三、编译型语言与解释型语言

- **编译型**：编译型语言会通过编译器将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。
- **解释型**：解释型语言会通过解释器一句一句的将代码解释为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。

![编译型语言和解释型语言](https://raw.githubusercontent.com/KKKLxxx/img-host/master/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6769746875622f6a61766167756964652f6a6176612f62617369732f636f6d70696c65642d616e642d696e7465727072657465642d6c616e6775616765732e706e67)

**Java程序从源代码到运行的过程**：

![Java程序转变为机器代码的过程](https://raw.githubusercontent.com/KKKLxxx/img-host/master/68747470733a2f2f67756964652d626c6f672d696d616765732e6f73732d636e2d7368656e7a68656e2e616c6979756e63732e636f6d2f6769746875622f6a61766167756964652f6a6176612f62617369732f6a6176612d636f64652d746f2d6d616368696e652d636f64652e706e67)

我们需要格外注意的是`.class->机器码`这一步。在这一步**JVM类加载器首先加载字节码文件，然后通过解释器逐行解释执行**，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的（也就是所谓的热点代码），所以后面引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。**当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用**。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说**Java是编译与解释共存的语言** 

## 四、值传递与引用传递

程序设计语言将实参传递给方法（或函数）的方式分为两种：

- **值传递**：方法接收的是实参值的拷贝，会创建副本
- **引用传递**：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参

很多程序设计语言（如C++）提供了两种参数传递的方式，不过，**在 Java 中只有值传递**

- 对于**基本数据类型**，Java传递的是实际值的副本

- 对于**引用类型（对象）**，Java传递的是引用的副本，也就是原引用和引用副本均指向同一个对象，通过引用副本修改对象会使原对象改变。但如果将该副本指向新的对象，则不会再对原对象造成影响。**关键：无法修改原引用的指向，所以说明只是值传递**

## 五、4种访问权限

- **public**：所有包、类均可见

- **protected**：有继承关系的类可见

- **default**：只有同一个包内的类可见

- **private**：只有同一个类可见

**Q：如何获取其他类的私有变量**

A：利用getter()方法或者反射机制

## 六、Object类有哪些方法？

- hashCode()与equals()
- toString()：默认返回类名加@加对象的哈希码十六进制表示，比如 User@1b6d3586
- clone()：用于创建对象的浅拷贝，使用 clone 需要让类实现 Cloneable 接口，否则会抛出 CloneNotSupportedException
- getClass()：返回对象所属的类，从而获取类的属性和方法，常用于反射场景
- wait() / notify() / notifyAll()

## 七、native方法

native方法是一种特殊类型的方法，它允许Java代码调用外部的本地代码，即用C、C++或其他语言编写的代码。native关键字是Java语言中的一种声明，用于标记一个方法的实现将在外部定义

## 八、如何对一个类自定义排序？

可以使类实现Comparable接口，并重写compareTo方法，然后在compareTo方法中实现排序逻辑

```java
public class Student implements Comparable<Student> {
    private int id;
    private int score;
    
    // 构造方法和其他属性、方法省略
    
    @Override
    public int compareTo(Student other) {
        if (this.score != other.score) {
            return Integer.compare(other.score, this.score); // 按照分数降序排序
        } else {
            return Integer.compare(this.id, other.id); // 如果分数相同，则按照学号升序排序
        }
    }
}
```

然后在需要对学生列表进行排序的地方，使用Collections.sort()方法对学生列表进行排序即可：

```java
Collections.sort(students);		// students为List<Student>类型
```

