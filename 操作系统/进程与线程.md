# 进程与线程

## 一、进程

### 1. 进程的组成

进程包括两部分：**程序**和**进程信息**

程序就是就是我们的代码编译后的可执行文件，程序本身不是进程，程序只是被动实体

进程信息通常通过进程控制块（PCB，Process Control Block）表示

#### 1.1 PCB包括什么

1、**进程状态**：包括新的、就绪、运行、等待、停止等

2、**程序计数器**：表示将要执行的下个指令的地址

3、**CPU寄存器**：包括累加器、索引寄存器、堆栈指针、通用寄存器等。发生中断时，这些状态信息与程序计数器一起需要保存，以便进程能够恢复

4、**CPU调度信息**：包括进程优先级、调度队列的指针等

5、**内存管理信息**：包括基地址和界限寄存器的值、页表或段表

6、**记账信息**：包括CPU时间、实际使用时间、时间期限、进程数量等

7、**I/O状态信息**：包括分配给进程的I/O设备列表，打开文件列表等

### 2. 进程状态

1、**新的**（new）：进程正在创建

2、**运行**（running）：指令正在执行

3、**等待**（waiting）：进程等待某个事件的发生（如I/O完成或收到信号）

4、**就绪**（ready）：进程等待分配处理器

5、**终止**（terminated）：进程已经完成执行

状态转换图如下

<img src="https://raw.githubusercontent.com/KKKLxxx/img-host/master/202111102109104.png" alt="image-20211110210912038" style="zoom:50%;" />

### 3. 进程的创建与终止

#### 3.1 进程的创建

在Linux中，有一个pid为1的init进程，它是所有进程的父进程。父进程可以创建子进程，而子进程需要的资源可以从操作系统那里直接获取，也可以只从父进程那里获取资源子集。限制子进程只能使用父进程的资源，可以防止创建过多进程导致系统超载

除了提供资源外，父进程也可以向子进程传递初始化数据。通过系统调用`fork()`可以创建新进程，新进程的地址空间复制了原来进程的地址空间，这种机制允许父进程与子进程轻松通信

#### 3.2 进程的终止

当进程执行完成最后的语句并通过系统调用`exit()`请求操作系统删除自身时，进程终止。这时，进程可以返回状态值到父进程（通过系统调用`wait()`），所有进程资源会由操作系统释放

一个进程可以通过系统调用终止另一个进程，但是通常只有被终止进程的父进程可以执行这一系统调用

#### 3.3 僵尸进程与孤儿进程

**当一个进程终止时，操作系统会释放其资源。不过，它位于进程表中的条目还是存在的，直到它的父进程调用wait()，这是因为进程表包含了进程的退出状态**

**当进程已经终止，但是其父进程还未调用wait()，这样的进程称为僵尸进程**。所有进程终止时都会过渡到这种状态，但是一般而言僵尸只是短暂存在。一旦父进程调用了`wait()`，僵尸进程的条目就会释放

**如果父进程没有调用wait()就终止，子进程就会成为孤儿进程**。这种情况下，孤儿进程会把init进程作为父进程，init定期调用`wait()`，便可以释放进程条目

僵尸进程与孤儿进程的区别在于，如果因为父进程错误，导致迟迟不调用`wait()`，那么僵尸进程过多会导致进程条目积压，占用资源。而孤儿进程会被init进程定期收集，定期释放，不会有太大的资源占用

### 4. 进程间通信

进程间通信（IPC，InterProcess Communication）主要有两种方式：**共享内存**和**消息传递**

共享内存方式一旦建立起共享区域，就可以像常规内存访问一样进行进程间通信，所以

#### 4.1 共享内存

通过建立进程间的共享内存区域即可实现IPC，常见于生产者-消费者问题，可用于建立公共缓冲区

可通过分页/分段等虚拟内存技术实现

#### 4.2 消息传递

消息传递的方式有很多种

##### 4.2.1 管道

**管道就是内核里的一段缓存**，从一段写入，从另一端读出，类似于队列结构。管道也有2种类型，匿名管道和命名管道

###### 4.2.1.1 匿名管道

匿名管道是**单向通信**的，并且**只允许建立在父子进程之间**，一旦进程结束，匿名管道也就不存在了

如果要双向通信，需要建立2条匿名管道

由于父子进程的限制，匿名管道**只能在同一台机器的不同进程间进行通信**

###### 4.2.1.2 命名管道

命名管道与普通管道的区别在于，命名管道在**进程结束后可以继续存在**，**不要求通信双方具有父子关系**，并且是**半双工**的，不过命名管道仍然**只能在同一台机器的不同进程间进行通信**

命名管道类似于一个消息队列，但是由于它是半双工的，所以如果要实现双方同时发送、接受信息，仍然需要建立2条命名管道

##### 4.2.2 消息队列

消息队列是保存在内核中的消息链表

消息的发送方和接收方要**约定好消息体的数据类型**，所以每个消息体都是固定大小的存储块，不像**管道是无格式的字节流数据**

##### 4.2.3 信号

信号是Linux内置的一种**通知机制**，不能用于传输消息

最常见的是kill相关的信号，最常用的是[-9]（强制结束）和[-15]（正常结束），如果不加选项则默认为[-15]

对于[-15]的kill，程序会先进行结束前的准备工作，包括正常释放资源、清理临时文件等。所以这个kill信号**可能被阻塞或忽略**，导致无法立刻结束进程。这时候可以加上`-9`

```
kill -9 3268
```

然而[-9]的副作用就是可能造成一些数据的丢失

也可通过键盘快捷键的方式发出信号，比如`CTRL+Z`

##### 4.2.4 信号量

用于进程间的同步与互斥，通过PV操作来实现

##### 4.2.5 套接字（socket）

套接字为通信的端点，每个套接字由一个IP地址和一个端口号组成，所以可以用于标识每一个进程。通信时，只要通过套接字就可以进行面向连接（TCP）或者无连接（UDP）的通信

套接字通信常用且高效，但是是一种低级形式的通信。因为它只能交换无结构的字节流，客户端与服务端需要自己加上数据结构

优点在于**能够实现不同主机上的进程通信**

##### 4.2.6 远程过程调用（RPC）

（但这应该不属于操作系统层面的通信方式了）

RPC是最为常用的远程服务，它交换的信息具有明确结构，RPC也是通过地址+端口号来进行连接的

由于常见的网络错误，RPC可能执行失败或重复执行多次，所以RPC需要保证每个消息执行“正好一次”。为达到这个目的，RPC在原有消息的基础上添加了时间戳和ACK

时间戳能够保证客户端对于每一条消息只处理一次，即使重复收到一条消息也可以通过对比时间戳然后丢弃；ACK机制是在客户端收到一条消息后返回ACK，让服务器知道客户端已成功接收，不用再重复发送

### 5. 进程调度

进程调度的目的是让当前正在I/O或等待事件发生的进程放弃CPU，从而让其他进程使用CPU，以保证CPU利用率最大化。然而在多核系统下，进程调度往往是指线程调度，这两种调度虽有差别但是往往可以交替使用

#### 5.1 长期调度与短期调度

**长期调度**：也称作业调度，即进程调度。它的作用可以概括为创建进程，将进程加载到内存中

**短期调度**：也称CPU调度，即线程调度。它的作用是选择内存中的进程（线程），并为其分配CPU

**区别**：**长期调度执行频率低，用于控制内存中的进程数量；短期调度执行频率高，用于最大化CPU使用率**，为避免大量时间被用在CPU调度上，短期调度速度应该尽可能快

#### 5.2 调度准则

1、**CPU使用率（CPU utilization）**：使用率越高说明调度程序越高效

2、**吞吐量（throughput）**：一个时间单元内进程完成的数量

3、**周转时间（turnaround time）**：从进程提交到进程完成的时间

4、**等待时间（waiting time）**：在就绪队列中等待所花时间之和，在数值上等于(周转时间-CPU运行时间)

5、**响应时间（response time）**：从进程提交到产生第一响应的时间，与周转时间的区别在于不考虑结果输出所需要的时间，周转时间通常受输出设备速度的限制

#### 5.3 调度算法

##### 1、先到先服务（FCFS，First-Come First-Served）

先到先服务实现简单、容易理解，但是**平均等待时间往往很长**，属于非抢占调度

##### 2、短作业优先（SJF，Shortest Job First）

SJF分2种，一种是抢占式的，称为最短剩余时间优先（**SRTF**，Shortest-remaining-time-first）它在每次有新进程达到就绪队列时触发一次竞争；一种是非抢占式的，会等到当前进程运行完再去竞争。抢占式SJF更常用

**SJF算法是最优的，因为它的平均等待时间最小**

##### 3、优先级调度（PS，Priority Scheduling）

也可以分为抢占与非抢占，区别与SJF的抢占与非抢占类似

PS**容易造成饥饿问题**，解决方法是**提高等待时间很久的进程的优先级**

##### 4、时间片轮转（RR，Round Robin）

专门为分时系统设计，为每个进程分配一个时间片，以FCFS的方式获取CPU时间，**平均等待时间通常较长**

如果时间片过大，会等同于FCFS；如果时间片过小，会造成大量的上下文切换，CPU利用率很低

##### 5、多级队列（Multilevel Queue）

根据进程的不同属性，如内存大小、优先级等，分到不同的队列，**每个队列采用不同的调度算法**

比如，前台程序的队列采用RR算法，后台程序的队列采用FCFS算法。两个队列之间也可以有优先级的差异，即前台程序优先级高于后台程序

##### 6、多级反馈队列（Multilevel Feedback Queue）

多级队列的调度开销低，但是不够灵活。因为一个程序的属性可能会随着运行的变化而变化，也许一开始适合RR算法，后来就更适合SJF算法，如果属性改变后仍然停留在原队列中，效率会有一定降低

多级反馈队列算法**允许进程在队列之间迁移**，以达到最高利用率

## 二、线程

由于教科书上没有像进程一样详细讨论线程，所以这里的线程主要是指Java线程

### 1. 线程的六状态

1、**新建（New）**

创建后尚未启动的线程处于这种状态

2、**运行（Runnable）**

包括操作系统线程状态中的Running和Ready，也就是处于此状态的线程**有可能正在执行，也有可能正在等待着操作系统为它分配执行时间**

3、**无限期等待（Waiting）**

处于这种状态的线程不会被分配处理器执行时间，它们**要等待被其他线程显式唤醒**。以下方法会让线程陷入无限期的等待状态：

* 没有设置Timeout参数的Object::wait()方法；

* 没有设置Timeout参数的Thread::join()方法；

4、**限期等待（Timed Waiting）**

处于这种状态的线程也不会被分配处理器执行时间，不过**无须等待被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒**。以下方法会让线程进入限期等待状态：

* Thread::sleep()方法

* 设置了Timeout参数的Object::wait()方法

* 设置了Timeout参数的Thread::join()方法

5、**阻塞（Blocked）**

线程被阻塞了，**“阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取到一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生**；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态

6、**结束（Terminated）**

已终止线程的线程状态，线程已经结束执行

上述6种状态在遇到特定事件发生的时候将会互相转换，它们的转换关系如图所示

<img src="https://raw.githubusercontent.com/KKKLxxx/img-host/master/202111121932599.png" style="zoom:50%;" />

## 三、进程线程对比

1、**进程是资源分配的最小单位，线程是CPU调度的最小单位**

2、**一个进程可以包含多个线程**

3、**线程上下文切换更快。因为进程有完全独立的资源，线程大部分资源都是共享进程的，只有少量独立资源**

4、**一个进程崩溃不影响其他进程，一个线程崩溃会导致整个进程崩溃**（JVM捕获了栈溢出和空指针两个常见的异常，交给用户处理，使得JVM不会崩溃，增强了程序的健壮性）

### 1. 线程独立拥有进程的哪些资源

主要有线程的栈（保存函数调用的地址）、寄存器、程序计数器

### 2. 线程共享进程的哪些资源

PCB中除了上面所述线程独有的资源

主要有堆、代码区、数据区（全局变量）、IO设备及打开文件的列表

### 3. 为什么进程上下文切换代价比线程大

因为如果只是在同一进程下的线程交换，那么大部分数据都是共享的，即相同的，就免去了很多保存、切换的消耗。而进程与进程之间资源完全独立，切换进程时需要完全切换

### 4. 多进程与多线程的选择

**多进程**：计算密集时选用，因为每个进程独立拥有资源，资源越多，计算也就越快

**多线程**：IO密集时选用，因为大部分时间都在等待，切换上下文代价小
