# 内存管理

## 一、虚拟内存

操作系统通过两个寄存器来确定进程的内存空间

- **基地址寄存器**：含有最小的合法的物理内存地址
- **界限地址寄存器**：指定了范围的大小

当用户访问范围外的内存时，会进入内核态，操作系统会处理这个寻址错误。这两个寄存器的值需要通过特权指令修改，而特权指令只能在内核态执行，所以用户无法修改

CPU生成的地址称为逻辑地址（虚拟地址），内存单元看到的地址称为物理地址。编译时和加载时的地址绑定方法生成相同的逻辑地址和物理地址，执行时的地址绑定方法生成不同的逻辑地址和物理地址

从虚拟地址到物理地址的运行时映射由**内存管理单元**（Memory-Management Unit, **MMU**）来完成。

虚拟内存的管理方法有分段和分页等，虚拟内存将用户逻辑内存与物理内存分开，可提供以下好处

- 虚拟内存可提供大于物理内存的内存，程序不再受物理内存的可用量所限制，同时可以实现部分空间的复用（共享内存）
- 每个程序可占用较少的物理内存（只在内存中加载需要运行的部分），因此可同时运行更多程序
- 加载或切换程序到内存的IO更少，程序运行更快

## 二、分段

分段是将逻辑地址空间分为多种段，每个段都有名称和长度，地址指定了段名称和段内偏移。因此用户通过两个量来指定地址：段名称和段偏移

为了简单，往往对段名称编号，所以逻辑地址由一个有序对组成：**<段号，偏移>**

在编译用户程序时，编译器会根据输入程序来自动构造段，可能包括

- 代码
- 变量
- 堆
- 栈

虽然用户能够通过二维地址来引用程序内的对象，但是实际物理内存仍然是一维的字节序列。因此，需要通过**段表**来实现二维地址到一维地址的映射。段表的每个条目都有段基地址和段界限

<img src="https://raw.githubusercontent.com/KKKLxxx/img-host/master/image-20220316145649739.png" alt="image-20220316145649739" style="zoom:50%;" />

## 三、分页

分页是将**物理**内存分为固定大小的块，称为**帧**；而将**逻辑**内存也分为同样大小的块，称为**页**。当需要执行一个进程时，它的页从文件系统加载到内存的可用帧

CPU生成的地址包括两部分：**页码**和**页偏移**，页码作为**页表**的索引，页表包含每页所在物理内存的基地址，基地址与页偏移的组合形成物理地址

<img src="https://raw.githubusercontent.com/KKKLxxx/img-host/master/image-20220316160834326.png" alt="image-20220316160834326" style="zoom: 67%;" />

如果逻辑空间地址为`2^m`，且页大小为`2^n`，那么逻辑地址的高`m-n`位表示页码，低`n`位表示页偏移，如下图

<img src="https://raw.githubusercontent.com/KKKLxxx/img-host/master/image-20220316154826208.png" alt="image-20220316154826208" style="zoom: 67%;" />

如果程序试图访问尚未调入内存中的页，会发生**缺页错误**，系统会中断并进行**请求调页**

**页面置换算法**主要有：

1、FIFO页面置换：先进先出

2、最优页面置换：置换最长时间不会使用的页面（难以实现）

3、LRU页面置换：最近最少使用

**帧分配**：可以根据各个进程的实际需要，分配不同的帧数。分配方法包括平均分配、比例分配。在页面置换时也可以局部置换，即只在属于该进程的帧中进行置换，与之相反的是全局置换

**系统抖动**：指因缺页而频繁地请求调页导致的性能问题。可以从页面置换、帧分配两方面优化

## 四、分段与分页的区别

分段有外部碎片，分页有内部碎片

分页方案中，由于物理内存的帧大小与虚拟内存的页大小相同，所以交换空间时效率更高

## 五、段页式内存管理

内存分段和内存分页并不是对立的，它们是可以组合起来在同一个系统中使用的，那么组合起来后，通常称为**段页式内存管理**

<img src="https://raw.githubusercontent.com/KKKLxxx/img-host/master/f19ebd6f70f84083b0d87cc5e9dea8e3.png" alt="img" style="zoom:80%;" />

段页式内存管理实现的方式：

- 先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制
- 接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页

这样，地址结构就由**段号、段内页号和页内位移**三部分组成。

用于段页式地址变换的数据结构是每一个程序一张段表，每个段又建立一张页表，段表中的地址是页表的起始地址，而页表中的地址则为某页的物理页号，如图所示：

<img src="https://raw.githubusercontent.com/KKKLxxx/img-host/master/8904fb89ae0c49c4b0f2f7b5a0a7b099.png" alt="img" style="zoom: 67%;" />

段页式地址变换中要得到物理地址须经过三次内存访问：

- 第一次访问段表，得到页表起始地址
- 第二次访问页表，得到物理页号
- 第三次将物理页号与页内位移组合，得到物理地址

可用软、硬件相结合的方法实现段页式地址变换，这样虽然增加了硬件成本和系统开销，但提高了内存的利用率

