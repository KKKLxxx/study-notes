# 死锁与同步

## 一、死锁

### 1、死锁的定义

**如果所申请的资源被其他进程占有，那么该进程可能再也无法改变状态**，这种情况称为死锁

### 2、死锁的四个必要条件

1、**互斥（mutual exclusion）**：至少有一个资源处于非共享模式

2、**占有并等待（hold and wait）**：一个进程至少占有一个资源，并等待另一个资源，而该资源被其他进程占有

3、**非抢占（no preemption）**：资源不能抢占

4、**循环等待（circular wait）**：有一组进程P0-Pn，P0等待的资源被P1占有，P1等待的资源被P2占有，...，Pn等待的资源被P0占有

### 3、死锁的处理方法

#### 1、死锁预防

可以从死锁的4个必要条件入手，来预防死锁

**1、互斥**

使资源可以共享，比如读文件就可以共享

但是这点不通用，因为很多资源必须是互斥的

**2、占有并等待**

可以将“占有”和“等待”拆开，不满足“占有”的话，就是进程申请资源时必须本身不占有任何资源；不满足“等待”的话，就是只有当所有资源都可用时才可以申请

这种方式效率很低并且可能发生饥饿

**3、非抢占**

如果一个进程持有资源并等待其他资源，那么它现在所拥有的资源可以被抢占

**4、循环等待**

对所有资源类型进行排序，每个进程需要按照递增顺序来申请自愿

#### 2、死锁避免

首先介绍一个概念：**安全状态**

**如果系统能够按照一定顺序为每个进程分配资源，且不会产生死锁**，那么这个系统就处于安全状态。具体的，假设按以下序列为进程分配资源<P1, P2, ..., Pn>，对于每个Pi，如果“Pi申请的资源数”小于“当前可用资源数 + Pi之前的所有进程所占有的资源数”，那么这个序列就是**安全序列**。**如果存在一个安全序列，那么系统就处于安全状态**；如果不存在，那么系统就处于非安全状态，不过**非安全状态不一定会产生死锁**

死锁避免算法就是用来算出这样一个安全序列，如果有结果，说明系统安全，就可以按照这个序列来分配资源，达到死锁避免的效果

##### 1、资源分配图算法（Resource allocation graph）

在资源分配图的基础上，添加一种边，需求边（claim edge），用虚线表示。需求边Pi->Rj表示，进程Pi会在未来某个时间申请资源Rj

该算法保证**将申请边变为分配边后不会产生环，才可以申请**

如图7-7，假设进程P2申请资源R2，虽然R2现在可用，但是不能将它分配给P2，因为这会创建一个环（如图7-8）

<img src="https://raw.githubusercontent.com/KKKLxxx/img-host/master/202111111944154.png" alt="image-20211111194424117" style="zoom: 67%;" />

##### 2、银行家算法（Banker’s Algorithm)

**资源分配图算法只适用于每种类型资源只有单个实例的场景**。如果有多个实例，就需要银行家算法

假设n为进程数，m为资源类型数。定义以下数据结构

- Available：长度为m的向量，表示每种资源可用实例数

- Max：n x m矩阵，表示每个进程对每种资源的最大需求数

- Allocation：n x m矩阵，表示每个进程已经分配的各种资源的实例数
- Need：n x m矩阵，表示每个进程最大还需要的实例数

其中，`Need[i][j] = Max[i][j] - Allocation[i][j]`

为了简化表示，规定，对于两个长度为n的向量X和Y，如果对于任意i ∈ [1, n]均有X[i] <= Y[i]，那么X <= Y。可以将矩阵的每一行看做一个向量，比如Max矩阵的第1行可以用Max1表示

对每个进程，需要满足**Need <= Available**，如果能够找到一个安全序列，说明安全

#### 3、死锁检测

如果不进行死锁预防和死锁避免，就需要定期检测死锁，如果发生死锁，需要人工或者死锁恢复算法干预

死锁检测的算法与死锁避免的算法几乎相同

#### 4、死锁恢复

当死锁已经发生时，就需要进行死锁恢复，有以下几种方法

1、一次性终止所有死锁进程

2、逐个终止死锁进程，直到死锁恢复

3、抢占资源

## 二、同步

### 1、临界区（Critical Section）问题

进程同步问题可以抽象称为**临界区**问题，我们要保证没有两个进程可以在它们的临界区内同时执行

规定临界区、进入区（entry section）、退出区（exit section）、剩余区（remainder section）的通用结构如下

<img src="https://raw.githubusercontent.com/KKKLxxx/img-host/master/202111111605780.png" alt="image-20211111160514735" style="zoom: 80%;" />

临界区问题的解决方案需要满足如下3条要求：

1、**互斥（mutual exclusion）**：如果进程P在其临界区内执行，那么其他进程都不能在该临界区内执行

2、**进步（progress）**：如果没有进程在临界区内执行，并且有进程需要进入临界区，则需要选择一个进程进入临界区，这个选择不能被无限推迟

3、**有限等待（bounded waiting）**：从一个进程做出进入临界区的请求直到这个请求允许为止，其他进程允许进入其临界区的次数有上限

### 2、同步方式

#### 1、锁

##### 1、互斥锁（Mutex Lock）

一个进程在进入临界区时得到锁，在退出临界区时释放锁。函数**acquire()**获取锁，函数**release()**释放锁

<img src="https://raw.githubusercontent.com/KKKLxxx/img-host/master/202111111617714.png" alt="image-20211111161731680" style="zoom:80%;" />

每个互斥锁有一个布尔变量available，它表示锁是否可用。如果锁是可用的，那么调用acquire()会成功，并且锁不再可用。当一个进程试图获取不可用的锁时，会被阻塞，直到锁被释放。acquire()与release()的定义如下

```c
acquire() {
    while (!available) {
    	/* busy wait */
    }
    available = false;
}
```

```c
release() {
	available = true;
}
```

##### 2、自旋锁

##### 3、读写锁

#### 2、信号量（Semaphore）

信号量是一个整型变量，有3种操作：初始化、**wait()**（简写为P）、**signal()**（简写为V）

wait()与signal()的定义如下

```c
wait(S) {
    while (S <= 0) {
    	/* busy wait */
    }
    S--;
}
```

```c
signal(S) {
	S++;
}
```

##### 1、二进制信号量

二进制信号量的值只能为0或1，效果与互斥锁基本相同

##### 2、计数信号量

计数信号量可以用于控制访问具有多个实例的某种资源，其初始值为可用资源数。通过wait()获取资源并减少信号量S的值，通过signal()释放资源并增加S的值，当S=0时，wait()操作会被阻塞

### 3、经典同步问题

#### 1、有界缓冲问题（Bounded Buffer Problem）

即生产者-消费者问题。信号量mutex提供缓冲区访问的互斥要求，信号量empty和full分别被用于表示空的和满的缓冲区的数量

#### 2、读者-作者问题（Reader Writer Problem）

**第一读者-作者问题**：读者不应保持等待，除非作者已获得权限使用共享对象。会造成**作者饥饿**

**第二读者-作者问题**：如果有作者在等待访问对象，那么不会有新的读者开始读。会造成**读者饥饿**

#### 3、哲学家就餐问题

**问题概述**：5位哲学家坐在圆桌上，他们只会思考和吃饭。他们每两人之间有一根筷子，共5根。只有当一个人同时拿起2只筷子时才可以吃饭，吃完后立刻放下筷子。每个人只能拿自己身边的两根筷子，也不能从其他人手上抢夺筷子。**当每个人同时拿起自己左边或者右边的筷子各一根时，就会产生死锁**

**死锁的解决方案**：

1、筷子数量不变，但最多允许4个人同时坐在桌子上

2、只有一个人左右两边筷子都可用时，才可以拿起筷子

3、给每个人编号，单号先拿左边的筷子，再拿右边的筷子；双号先拿右边的筷子，再拿左边的筷子

