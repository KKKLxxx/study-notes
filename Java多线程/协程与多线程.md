# 协程与多线程

一、多线程的缺陷
--------

现代B/S系统中一次对外部业务请求的响应，往往需要分布在不同机器上的大量服务共同协作来实现，这种服务细分的架构在减少单个服务复杂度、增加复用性的同时，也不可避免地增加了服务的数量，缩短了留给每个服务的响应时间。这要求每一个服务都必须在极短的时间内完成计算，这样组合多个服务的总耗时才不会太长；也要求每一个服务提供者都要能同时处理数量更庞大的请求，这样才不会出现请求由于某个服务被阻塞而出现等待

Java目前的并发编程机制就与上述架构趋势产生了一些矛盾，1：1的内核线程模型是如今Java虚拟机线程实现的主流选择，但是这种映射到操作系统上的线程天然的**缺陷是切换、调度成本高昂，系统能容纳的线程数量也很有限**。以前处理一个请求可以允许花费很长时间在单体应用中，具有这种线程切换的成本也是无伤大雅的，但现在**在每个请求本身的执行时间变得很短、数量变得很多的前提下，用户线程切换的开销甚至可能会接近用于计算本身的开销，这就会造成严重的浪费**

**二、什么是协程**
-----------

正如上面所说，多线程的缺陷是切换成本高，且线程数量也受内存限制，而协程可以弥补这两个问题。协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。**协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程**，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多

三、协程的注意事项
---------

实际上协程并不是什么银弹，协程只有在等待IO的过程中才能重复利用线程，而线程在等待IO的过程中会陷入阻塞状态。假设协程运行在线程之上，并且协程调用了一个阻塞IO操作，但实际上操作系统并不知道协程的存在，它只知道线程。**因此在协程调用阻塞IO操作的时候，操作系统会让线程进入阻塞状态，当前的协程和其它绑定在该线程之上的协程都会陷入阻塞而得不到调度，这往往是不能接受的**

因此在协程中不能调用导致线程阻塞的操作，也就是说，协程只有和异步IO结合起来，才能发挥最大的威力

四、协程的使用场景
---------

即IO密集型业务