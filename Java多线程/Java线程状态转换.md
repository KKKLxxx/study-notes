# Java线程状态转换

Java语言定义了6种线程状态，在任意一个时间点中，一个线程只能有且只有其中的一种状态，并且可以通过特定的方法在不同状态之间转换。这6种状态分别是：

一、新建（New）
---------

创建后尚未启动的线程处于这种状态

二、运行（Runnable）
--------------

包括操作系统线程状态中的Running和Ready，也就是处于此状态的线程**有可能正在执行，也有可能正在等待着操作系统为它分配执行时间**

三、无限期等待（Waiting）
----------------

处于这种状态的线程不会被分配处理器执行时间，它们**要等待被其他线程显式唤醒**。以下方法会让线程陷入无限期的等待状态：

* 没有设置Timeout参数的Object::wait()方法；

* 没有设置Timeout参数的Thread::join()方法；

* LockSupport::park()方法

四、限期等待（Timed Waiting）
---------------------

处于这种状态的线程也不会被分配处理器执行时间，不过**无须等待被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒**。以下方法会让线程进入限期等待状态：

* Thread::sleep()方法；

* 设置了Timeout参数的Object::wait()方法；

* 设置了Timeout参数的Thread::join()方法；

* LockSupport::parkNanos()方法；

* LockSupport::parkUntil()方法

五、阻塞（Blocked）
-------------

线程被阻塞了，**“阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取到一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生**；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态

六、结束（Terminated）
----------------

已终止线程的线程状态，线程已经结束执行

上述6种状态在遇到特定事件发生的时候将会互相转换，它们的转换关系如图所示

<img src="https://raw.githubusercontent.com/KKKLxxx/img-host/master/202111121932599.png" style="zoom:50%;" />

---

**Q：为什么将Running与Ready合并为一个Runnable**

A：因为线程在Running与Ready两个状态之间的转换是非常快的，具体到某一个状态的意义不大。并且Java不太需要关于底层的线程调度，完全交给OS处理即可

