# Redis常用数据类型及使用场景

Redis常见的数据类型有5种：**String（字符串）、Hash（哈希）、List（列表）、Set（集合）、Zset（有序集合）**

随着版本的更新，后面又支持了4种数据类型：**BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）**

## 一、String

### 1. 基本介绍

String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值，value其实不仅是字符串， 也可以是数字（整数或浮点数）

### 2. 底层结构

String 类型的底层的数据结构实现是 **SDS**（简单动态字符串）

### 3. 使用场景

#### 3.1 常规计数

利用Redis单线程操作的特性，可以保证高并发环境下计数的准确性

比如计算访问、点赞、转发次数等

#### 3.2 分布式锁

分布式锁可以保证多个服务之间互斥的访问共享资源，主要是利用`SETNX`命令只有当key不存在时才执行的特性，从而保证共享资源key在同一时刻仅被一个服务使用

#### 3.3 共享Session

将服务端的Session信息存储到Redis中，从而提高可扩展性

## 二、List

### 1. 基本介绍

List 列表是简单的字符串列表，按照插入顺序排序，可以从头部或尾部向 List 列表添加元素

### 2. 底层结构

在新版Redis中，List 数据类型底层数据结构只由 **quicklist** 实现，且这里quicklist由双向链表+listpack组成，而非双向链表+压缩列表

### 3. 使用场景

#### 3.1 消息队列

List通过`LPUSH/RPUSH, LPOP/RPOP `等指令可以实现一个简单的消息队列，但是对于顺序消费、重复消费、消息丢失等问题难以解决，并且不支持多个消费者消费同一条消息，仅可作为一种临时的消息队列使用

Stream也可作为消息队列且有所改进，但生产环境还应该用专业的消息队列中间件

## 三、Hash

### 1. 基本介绍

Hash 是一个键值对（key - value）集合，其中 value 的形式如：`value=[{field1，value1}，...{fieldN，valueN}]`，适合用于存储对象

### 2. 底层结构

| 条件                      | 使用结构    |
| ------------------------- | ----------- |
| field/value数量少 且 值短 | `listpack`  |
| field多 或 value大        | `hashtable` |

### 3. 使用场景

#### 3.1 缓存对象

一个对象通常包含多个字段，符合Hash结构的特点，但通常也会使用String+JSON的形式存储对象

如何选择：**当对象的属性经常变化时，可以用Hash存储；反之用String**

## 四、Set

### 1. 基本介绍

Set 类型是一个无序并唯一的键值集合，它的存储顺序不会按照插入的先后顺序进行存储

### 2. 底层结构

| 条件                     | 使用结构    |
| ------------------------ | ----------- |
| 所有元素是整数 且 数量小 | `intset`    |
| 出现非整数 或 元素变多   | `hashtable` |

### 3. 使用场景

#### 3.1 点赞列表

将key设置为文章ID，value是点赞的用户的ID集合，从而记录某文章所有点赞的用户

#### 3.2 共同关注

利用集合的交集计算，计算两个用户关注列表中的交集，从而得到共同关注

## 五、ZSet

### 1. 基本介绍

ZSet 类型（有序集合类型，Sorted Set）相比于 Set 类型多了一个排序属性 score（分值），每个存储元素相当于有两个值组成的，一个是有序集合的元素值member，一个是排序值

有序集合保留了集合不能有重复成员的特性（分值可以重复），但不同的是，有序集合中的元素可以排序

### 2. 底层结构

| 条件         | 使用结构               |
| ------------ | ---------------------- |
| 元素少 且 短 | `listpack`             |
| 元素多 或 长 | `skiplist + hashtable` |

对于`skiplist + hashtable`这个结构，**每一个 member 都对应一个独立的 skiplist 节点，同时也在 hashtable 中有一条记录**，也就是一个数据会存两遍：

- skiplist负责按score进行排序，并实现范围查询
- hashtable负责O(1)地查询member是否存在以及其对应的score值

如果只有skiplist，则查询较慢；如果只有hashtable，则不支持排序和范围查询

这种结构的代价就是会消耗更多空间，以及更新时需要维护两份数据

### 3. 使用场景

#### 3.1 实时排行榜

利用Redis操作快的特性，结合ZSet的按分数排序的功能，可用于实现实时排行榜

## 六、BitMap

### 1. 基本介绍

BitMap位图，是一串连续的二进制数组（0和1），可以通过偏移量（offset）定位元素

BitMap通过最小的单位bit来进行`0|1`的设置，表示某个元素的值或者状态，使用它进行储存将非常节省空间，特别适合一些数据量大且使用二元统计的场景

### 2. 底层结构

BitMap 的底层数据结构为**SDS**，SDS可以存储二进制的数组

### 3. 使用场景

#### 3.1 签到统计、在线状态

这两种场景都是只需要记录二元状态，即是否签到/是否在线

可以用日期作为key，用户id作为offset，进行状态的记录。若有5000W个用户，每个key仅需6MB空间

## 七、HyperLogLog

### 1. 基本介绍

HyperLogLog 用于基数统计，就是统计一个集合中不重复的元素个数，但要注意，HyperLogLog 是统计规则是基于概率完成的，不是非常准确，标准误算率是 0.81%

HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的内存空间总是固定且很小的

每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 $2^{64}$ 个不同元素的基数，和元素越多就越耗费内存的 Set 和 Hash 类型相比就非常节省空间

### 2. 底层结构

略

### 3. 使用场景

#### 3.1 百万级网页 UV 粗略统计

UV（Unique Visitor），以网页ID为key，每次将用户ID加入到该key中，Redis中不会记录用户ID，但能够根据算法对用户ID进行基数统计

而String只能用于统计PV（Page View）

## 八、GEO

### 1. 基本介绍

GEO主要用于存储地理位置信息，并对存储的信息进行操作

位置信息服务（Location-Based Service，LBS）应用访问的数据是和人或物关联的一组经纬度信息，而且要能查询相邻的经纬度范围，GEO 就非常适合应用在 LBS 服务的场景中

### 2. 底层结构

GEO 本身并没有设计新的底层数据结构，而是直接使用了 **ZSet** 类型，使用 GeoHash 编码实现经纬度到 ZSet 中元素权重分数的转换，并使用 ZSet 提供的“按权重进行有序范围查找”的特性，实现 LBS 服务中频繁使用的“搜索周边”的需求

### 3. 使用场景

#### 3.1 搜索周边

将附近商户的经纬度加入一个GEO集合中，再根据用户自身的经纬度，计算附近的商户有哪些

同样可用于打车场景

## 九、Stream

### 1. 基本介绍

Stream专门用于消息队列，相比Redis中其他两种用于实现消息队列的方法的缺陷

- 发布订阅：不能持久化，也就无法可靠的保存消息，且离线重连的客户端不能读取历史消息
- List：不能重复消费，且生产者需要自行实现全局唯一ID等

Stream支持以下功能：

- 消息持久化
- 自动生成全局唯一ID
- ACK确认
- 消费组模式

但Stream作为消息队列仍有以下缺陷：

- Redis持久化时宕机可能导致消息丢失
- 若消息积压导致内存不足，则不能接收新消息

