# Redis分布式锁

## 一、作用

在一个分布式系统中，多台机器上部署了多个服务，当客户端一个用户发起一个数据插入请求时，如果没有分布式锁机制保证，那么那多台机器上的多个服务可能进行并发插入操作，导致数据重复插入。而分布式锁机制就是为了解决类似这类问题，**保证多个服务之间互斥的访问共享资源**，如果一个服务抢占了分布式锁，其他服务没获取到锁，就不进行后续操作

## 二、实现方式

总体思路就是：

1、使用前尝试获取锁（添加一个key），获取成功即可使用

2、使用结束后释放锁（删除一个key）

3、同时设置一个超时释放时间，防止因redis宕机等原因无法正常释放锁

可以通过`SET`指令获取锁，如`SET lock server1 NX EX 10`，其中`NX`保证只有当key不存在时才会执行，`EX`可以指定过期时间，并且整个`SET`指令是一个原子操作，无需借助lua脚本将set和expire指令整合为一个原子操作

还要保证自己设置的锁只有自己能够删除，这可以通过将value设置成一个服务或线程的唯一ID实现。但是检测value和删除key需要保证是原子操作，否则可能产生并发问题，这个地方就需要lua实现

## 三、存在的问题

### 1. 可重入性

与常规可重入锁的实现思路一致，即需要记录每个线程获取锁的次数。在Redis中，可以将key设置为hash类型，hash中保存着两个属性，分别是锁的持有者和获取次数。每次获取时，将次数加一，每次释放时，将次数减一

### 2. 超时获取锁

想要达到一段时间内获取锁失败后再返回的效果，最简单的方法就是在这段时间内不断尝试获取锁，但是这种方式会极大浪费CPU

Redisson中提供了一种更高效的实现方式：

1、第一次尝试获取锁失败时，会返回一个ttl，代表锁的超时释放时间

2、判断等待时间是否大于0，如果是，则订阅一个锁释放的信号并开始等待

3、上一个锁的持有者释放锁时，会发送释放锁的信号，订阅者收到信号可以执行获取锁的操作

4、信号等待也有超时时间，若在该时间内没有信号产生，则返回获取失败

### 3. 长时间的任务

对于长时间的任务，锁的超时释放时间可能在任务执行结束之前，但我们需要保证锁的释放在任务执行结束之后。这可以通过让一个后台线程刷新未结束任务的过期时间来解决

### 4. 集群模式的数据一致性

在集群模式下，如果主节点执行完set指令后，还没来得及让从节点同步就宕机了，那么集群会重新选举一个主节点，那么就有可能存在多个服务同时拥有锁的情况

**RedLock方案**：使客户端与5个独立的Redis主节点交互（而不是一个集群中的5个节点），只有在多数节点上成功加锁，且加锁耗时小于锁过期时间时，才被认为成功加锁



