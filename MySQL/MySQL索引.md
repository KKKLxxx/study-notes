# MySQL索引

## 一、索引的作用和缺点

**作用**：**提高查询效率**，可以将随机IO变成顺序IO。与查阅图书所用的目录是一个道理：先定位到章，然后定位到该章下的一个小节，然后找到页数

**缺点**：创建和维护索引需要耗费额外的时间和空间，且在表内容较少时直接扫描效率更高

## 二、索引的结构

可以先熟悉一下相关数据结构

[B树（B-树）、B+树、红黑树](https://gitee.com/KKKLxxx/study-notes/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/B%E6%A0%91%EF%BC%88B-%E6%A0%91%EF%BC%89%E3%80%81B+%E6%A0%91%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91.md "B树（B-树）、B+树、红黑树")

**索引的数据结构**：主要为B+树（不可能在非叶子结点命中）

**不用哈希表的原因**：

1、仅支持等值查询，不支持范围查询

2、可能有哈希冲突，降低查询效率

3、不支持索引列的部分查找，因为哈希值是对所有索引列的计算

4、无法避免回表，因为索引中只有哈希值没有数据

5、数据量大时，可能无法一次性加载到内存中

**不用B树的原因**：

1、如果进行范围查询的话，B树每次都要从根节点开始查询，效率会有所降低（中序遍历？查询时间不稳定？）

2、B+树的非叶子节点只存储索引，没有数据，所以可以一次加载更多节点到内存中，减少IO次数

**不用红黑树的原因**：红黑树（二叉）的深度比B+树高，会增加磁盘IO次数

**使用B+树的优势**：

1、B+树叶子结点之间有互相连接的指针，所以更适合范围操作

2、B+树的非叶子节点不存储数据，所以在数据量很多时，树的高度也不会增长很快，查询速度比较稳定（高度一般在3-4层）

## 三、索引的使用场景

由于索引创建和维护都需要额外开销，所以以下几种情况都是**不推荐**使用索引的

1、**数据量小**：这时候全表扫描效率更高

2、**频繁更新**：数据的频繁更新会导致索引也频繁更新，有些索引，如聚簇索引，更新的代价可能极大

3、**唯一性差**：唯一性差的字段，如性别，只有两种，这时候索引的作用几乎无法体现

4、**索引在SQL语句无法被使用**：涉及索引失效情况，下面会介绍。如果索引失效，则应该删除相关索引，以避免索引的开销

所以索引的使用场景应该避免上面几种情况

## 四、索引分类

### 1、普通索引

最基本的索引，没有任何限制

### 2、主键索引

顾名思义，是以表中的主键为索引列创建的索引，会在创建表时**自动创建**，且**不能删除**。如果表中没有主键也就没有主键索引

### 3、唯一索引

索引列的值必须唯一，允许有空值

### 4、复合索引

组合索引指在多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循**最左匹配原则**

### 5、全文索引

全文索引主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引跟其它索引大不相同，它更像是一个搜索引擎，而不是简单的where语句的参数匹配

比如要搜索所有标题以“MySQL”开头的文章，也许可以选择在标题列创建一个索引，并使用“LIKE MySQL%”查询，但是LIKE相比全文索引效率低很多

然而全文索引的效率相比ElasticSearch还是低很多的，一般需要全文检索时都会选择ES，所以就不详细介绍全文索引了

## 五、索引相关SQL语句

### 1、查询

```
SHOW INDEX FROM table_name;
```

### 2、创建

```
-- 普通索引
ALTER TABLE table_name ADD INDEX index_name(column_name);

-- 唯一索引
ALTER TABLE table_name ADD UNIQUE INDEX index_name(column_name);

-- 复合索引
ALTER TABLE table_name ADD INDEX index_name(column_name1, column_name2, column_name3);

-- 全文索引
ALTER TABLE table_name ADD FULLTEXT INDEX index_name(column_name);
```

### 3、删除

```
DROP INDEX index_name ON table_name;
```

### 4、检验是否使用索引 

在语句前加"explain"，如

```
EXPLAIN SELECT * FROM table_name WHERE id = 1;
```

其中id为主键，则查询结果中，possible_keys会有一个结果为PRIMARY 

## 六、索引失效

具体案例可见

[MySQL索引失效案例](https://gitee.com/KKKLxxx/study-notes/blob/master/MySQL/MySQL%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E6%A1%88%E4%BE%8B.md "MySQL索引失效案例")

