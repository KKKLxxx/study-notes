# MySQL相关问题

## 一、数据库三大范式

**1、确保每列保持原子性**：比如地址可分为省份+城市+详细地址，所以应将地址拆分开

**2、确保每列都与主键相关**：例子与3类似

**3、确保每列都与主键直接相关而不是间接相关**：比如学号-所在院校-院校地址-院校电话，后两个属性与主键不是直接相关，应单独列一张表

**优点**：避免数据冗余，查询速度快

**缺点**：范式等级越高，表的数量越多，获取数据时表关联过多会导致性能下降

## 二、InnoDB与MyISAM对比

 从MySQL5.5以后，InnoDB是默认引擎

| **对比项**   | **InnoDB**         | **MyISAM**               |
| ------------ | ------------------ | ------------------------ |
| **外键**     | 支持               | 不支持                   |
| **事务**     | 支持               | 不支持                   |
| **锁类型**   | 行锁               | 表锁                     |
| **空间占用** | 大                 | 小                       |
| **表行数**   | 需要遍历全表       | 通过维护一个变量直接读取 |
| **使用场景** | 大量插入、更新操作 | 大量查询操作             |

**对于锁类型的特殊说明**：

InnoDB并非一定是行锁， 使用行锁的条件是走索引（注意索引失效问题），否则还是表锁

而MyISAM是不支持行锁，只能使用表锁

通常情况下，直接选择InnoDB即可

## 三、MySQL表名、列名包含空格、斜杠等特殊字符的处理方法

MySQL中如果想通过SQL语句建立一个列名为`身高/体重`或者`身高 体重`的字段，都会报错，因为`/`与` `都属于特殊字符

并且保留字也是不允许直接使用的，比如int, desc等

或者字段名只包含数字也是不允许的

处理方法就是给字段两边加上反引号

```
`
```

比如

```
create table 1111 (
	身高 体重 varchar(255),
	int varchar(255),
	123 varchar(255)
);
```

这种语句是错误的，但是可以通过加反引号解决

```
create table `1111` (
	`身高 体重` varchar(255),
	`int` varchar(255),
	`123` varchar(255)
);
```

![image-20211119201226752](https://raw.githubusercontent.com/KKKLxxx/img-host/master/202111192012794.png)

这样就成功建立了一张表名、列名都带有特殊字符的表



另外，在select或其他操作时，如果是常规的表名、列名，可以省略反引号，但是也可以加上。但对于特殊表名、列名，必须加上反引号才可正常查询

## 四、MySQL中varchar字段使用数字查询的特殊现象

在一次偶然中发现对varchar类型的字段查询时，没有严格将查询条件用引号括起来，导致出现了一些意外的结果

比如这么一张表，其中col为varchar类型

![](https://raw.githubusercontent.com/KKKLxxx/img-host/master/20211006224554131.png)

* * *

执行

```
SELECT * FROM tab1 WHERE col = 0
```

结果

![](https://raw.githubusercontent.com/KKKLxxx/img-host/master/20211006224633858.png)

* * *

执行

```
SELECT * FROM tab1 WHERE col = 1
```

结果

![](https://raw.githubusercontent.com/KKKLxxx/img-host/master/20211006224709413.png)

* * *

执行

```
SELECT * FROM tab1 WHERE col = 2
```

结果 

![](https://raw.githubusercontent.com/KKKLxxx/img-host/master/20211006224735730.png)

* * *

**总结如下**

对于col = 0的条件，可以匹配到所有（非数字开头）或（仅以0开头）或（单独一个数字0）的数据

对于col = x（其中x为数字，包括(正/负)(整/小)数）的条件，会匹配以x开头的所有数据，但如果x之后紧接着其他数字则不会被匹配。比如当x=11时，11a匹配，111不匹配，111a也不匹配

* * *

当然这只是一个偶然的发现，实际上肯定不会这么用的。所以**对varchar字段查询的时候一定要记得加引号**

## 五、MySQL自增主键与UUID如何选择

这两种主键需要在不同场景下选择

如果是**单机环境**，用自增主键是最好的。因为MySQL在InnoDB引擎下，会默认以主键创建一个聚簇索引。所以数据的插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此对于InnoDB表，一般都会定义一个自增的ID列为主键

如果是**分布式环境**，往往要考虑ID冲突。UUID是指Universally Unique Identifier，翻译为中文是**通用唯一识别码**，UUID的目的是让分布式系统中的所有元素都能有唯一的识别信息。如此一来，每个人都可以创建不与其它人冲突的UUID，就不需考虑数据库创建时的名称重复问题。所以分布式环境下往往会放弃一些性能，采用UUID

另外，UUID除了**插入速度慢于自增主键**，还会**占用更多的空间**。因为UUID是varchar类型的字段，而自增主键往往只是int或Bigint类型

## 六、为什么不推荐使用外键与级联

对于外键和级联，阿里巴巴开发手册这样说到：

> 【强制】不得使用外键与级联，一切外键概念必须在应用层解决。
>
> 说明：以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度

所以外键和级联的缺陷在于：

1、降低了更新操作的速度，容易死锁

2、无法用于分库分表场景

