# MySQL深度分页

## 一、问题描述

进行分页查询时，若offset过大，会产生深度分页，导致性能急剧下降

```sql
-- 当 offset 很大时，性能极差
SELECT * FROM orders ORDER BY id LIMIT 1000000, 20;
```

**问题原因**：

- MySQL 需要**先扫描 1000020 行**，然后**丢弃前 1000000 行**
- 即使使用索引，也要读取大量索引条目和数据
- 性能随 offset 增长**线性下降**

## 二、优化思路

### 1. 查询语句优化

#### 1.1 索引覆盖+子查询

由于原始语句会得到1000020行的每列数据，但实际只需要后20行的每列数据

通过索引覆盖+子查询的方式，可以仅获取1000020行的id（**索引覆盖，无需回表**），再单独获取20行的每列数据（**根据主键索引快速定位**），减少需要扫描的数据量

```sql
-- 优化1：使用索引覆盖先获取主键
SELECT * FROM orders 
WHERE id IN (
    SELECT id FROM orders 
    ORDER BY created_at DESC, id DESC 
    LIMIT 1000000, 20
);
```

#### 1.2 游标/连续分页

通用的分页查询是根据offset和pageSize直接确定所需要的数据，但在连续分页查询的场景中，可以记录上一页数据的最大id，在查询下一页数据时，通过where替代offset，从而利用索引提高查询速度

```sql
-- 传统分页（跳页查询）
SELECT * FROM orders 
ORDER BY id 
LIMIT 1000000, 20;  -- 性能差

-- 游标分页（连续分页）
-- 第一页
SELECT * FROM orders 
ORDER BY id 
LIMIT 20;

-- 第二页：记住第一页的最大ID（假设为1000）
SELECT * FROM orders 
WHERE id > 1000  -- 使用where条件代替offset
ORDER BY id 
LIMIT 20;
```

同理id可替换为时间等字段

### 2. 业务层优化

#### 2.1 避免深分页场景

比如在搜索场景中，通常不需要查看10、20页以后的搜索结果，所以可以只给用户提供前10页的查询按钮，从而避免offset过大

#### 2.2 避免跳页查询

如果只有连续分页功能，比如只有上一页/下一页的按钮，就可以避免跳页查询，但这会造成用户体验不太好

更常见的连续分页场景是瀑布流

### 3. 架构层优化

#### 3.1 用ES代替MySQL实现分页查询

ES等搜索引擎支持分布式，并且对分页查询有特殊的优化机制（Search After、Point in Time等，但具体原理不清楚），更适合进行深分页场景