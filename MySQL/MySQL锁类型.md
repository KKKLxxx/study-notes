# MySQL锁类型

## 一、按粒度划分

### 1、**表锁**

### 2、**行锁**

行锁有3种类型

- **记录锁（Record Lock）**：也被称为记录锁，属于单个行记录上的锁
- **间隙锁（Gap Lock）**：锁定一个范围，不包括记录本身
- **临键锁（Next-key Lock）**：`Record Lock + Gap Lock`，锁定一个范围，包含记录本身。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁

#### 间隙锁

临键锁是记录锁与间隙锁的组合，**准确的说，MySQL是通过临键锁解决的幻读问题**，但是一般都会混用间隙锁与临键锁这两个概念

##### 1、作用

临键锁用来**解决可重复读隔离级别下的幻读问题**，幻读就是其他事务增加、删除、修改了一条数据导致的，如果能够通过间隙锁暂时锁住，就可以避免幻读

具体来讲，就是**防止有新数据插入到间隙**或者**防止已有数据更新到间隙内**

##### 2、间隙锁生效条件

1、走索引：需要通过索引的排序来进行间隙划分，否则直接加表锁

2、可重复读（RR）级别

##### 3、间隙区域的划分

MySQL会根据检索条件，向其左右两边找到最接近的记录，并遵循以下原则

1、**左开右闭**

对于一张表

| id   |
| ---- |
| 1    |
| 3    |
| 7    |
| 9    |

会划分出以下几个区域：(负无穷，1]，(1，3]，(3，7]，(7，9]，(9，正无穷]

如果检索条件是`id = 3`，那么就会锁住(1，3]这个区间，所以此时会无法插入`id = 2`这条数据

2、**唯一索引的等值查询，且数据存在，变为记录锁**

由于唯一索引的唯一性，所以在等值查询时不需要间隙锁

**如果数据不存在，则仍为间隙锁**

##### 4、死锁问题

间隙锁不是互斥的，所以一个间隙锁可以被2个事务同时得到

假设(1，3]这个间隙锁被A、B两个事务同时占有，它们又都想插入`id = 2`这条数据，那么就会产生死锁

## 二、按共享策略划分

### 1、**共享锁**

又称：读锁，Share Lock，S锁

### 2、**排他锁**

又称：写锁，Exclusive Lock，X锁

### 3、**意向共享锁**与**意向排他锁**

- **意向共享锁（Intension Shared Lock，IS锁）**：事务有意向对表中的某些记录加共享锁（S锁），加共享锁前必须先取得该表的IS锁
- **意向排他锁（Intension Exclusive Lock，IX锁）**：事务有意向对表中的某些记录加排他锁（X锁），加排他锁前必须先取得该表的IX锁

**意向锁的作用**：当对一个行加锁之后，如果有事务打算给这张表加一个表锁，必须先看看该表的行有没有被加锁，否则就会出现冲突。IS锁和IX锁**避免为了判断表中有没有行锁而将每一行遍历**，直接查看表中有没有意向锁就可以知道表中有没有行锁

具体场景：事务A锁住了表中的一行，让这一行只能读，不能写。之后，事务B申请整个表的写锁。如果事务B申请成功，那么理论上它就能修改表中的任意一行，这与A持有的行锁是冲突的

数据库需要避免这种冲突，就是说要让B的申请被阻塞，直到A释放了行锁

数据库要怎么判断这个冲突呢？

step1：判断表是否已被其他事务用表锁锁表

step2：发现表上有意向共享锁，说明表中有些行被共享行锁锁住了，因此，事务B申请表的写锁会被阻塞

**申请意向锁的动作是数据库完成的，不需要程序员干预**

意向锁之间是互相兼容的

|       | IS 锁 | IX 锁 |
| ----- | ----- | ----- |
| IS 锁 | 兼容  | 兼容  |
| IX 锁 | 兼容  | 兼容  |

意向锁与共享锁和排它锁的互斥关系（这里指的是表级别的共享锁和排他锁，意向锁不会与行级的共享锁和排他锁互斥）

|      | IS 锁 | IX 锁 |
| ---- | ----- | ----- |
| S 锁 | 兼容  | 互斥  |
| X 锁 | 互斥  | 互斥  |

## 三、按加锁策略划分

### 1、**乐观锁**

适合冲突少的情况，利用CAS操作修改数据

使用方法：在数据库字段中添加一列“version”，在一个事务中，如果有对同一行数据的查询和更新操作，那么需要比较更新时和查询时的版本是否相同，如果相同才修改

### 2、**悲观锁**

适合冲突多的情况，一律先加锁再修改数据

使用方法：利用`select for update`直接加锁
