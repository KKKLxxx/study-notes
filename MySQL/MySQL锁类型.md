# MySQL锁类型

## 一、按粒度划分

### 1. 表锁

### 2. 行锁

行锁有3种类型

- **记录锁（Record Lock）**：也被称为记录锁，属于单个行记录上的锁
- **间隙锁（Gap Lock）**：锁定一个范围，不包括记录本身
- **临键锁（Next-key Lock）**：`Record Lock + Gap Lock`，锁定一个范围，包含记录本身。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁

## 二、按共享策略划分

### 1. 共享锁

又称：读锁，Share Lock，S锁

### 2. 排他锁

又称：写锁，Exclusive Lock，X锁

### 3. 意向锁

- 意向共享锁（Intension Shared Lock，IS锁）：事务有意向对表中的某些记录加共享锁（S锁），加共享锁前必须先取得该表的IS锁
- 意向排他锁（Intension Exclusive Lock，IX锁）：事务有意向对表中的某些记录加排他锁（X锁），加排他锁前必须先取得该表的IX锁

**意向锁的作用：快速判断表里是否有记录被加锁**

当对一个行加锁之后，如果有事务打算给这张表加一个表锁，必须先看看该表的行有没有被加锁。为了避免判断表中有没有行锁而将每一行遍历，直接查看表中有没有意向锁就可以知道表中有没有行锁

申请意向锁的动作是数据库完成的，不需要程序员干预

## 三、间隙锁/临键锁详细介绍

临键锁是记录锁与间隙锁的组合，**准确的说，MySQL是通过临键锁解决的幻读问题**，但是一般都会混用间隙锁与临键锁这两个概念

### 1. 作用

临键锁用来**解决可重复读隔离级别下的幻读问题**，幻读就是其他事务增加、删除、修改了一条数据导致的，如果能够通过间隙锁暂时锁住，就可以避免幻读

具体来讲，就是**防止有新数据插入到间隙**或者**防止已有数据更新到间隙内**

### 2. 间隙锁生效条件

- 走索引：需要通过索引的排序来进行间隙划分，否则直接加表锁

- 可重复读级别

### 3. 间隙区域的划分

MySQL会根据检索条件，向其左右两边找到最接近的记录，并遵循以下原则

#### 3.1 左开右闭

对于一张表

| id   |
| ---- |
| 1    |
| 3    |
| 7    |
| 9    |

会划分出以下几个区域：(负无穷，1]，(1，3]，(3，7]，(7，9]，(9，正无穷]

如果检索条件是`id = 3`，那么就会锁住(1，3]这个区间，所以此时会无法插入`id = 2`这条数据

#### 3.2 唯一索引的等值查询，且数据存在，变为记录锁

由于唯一索引的唯一性，所以在等值查询时不需要间隙锁

如果数据不存在，则仍为间隙锁

### 4. 间隙锁死锁问题

#### 4.1 死锁场景

测试数据：

```sql
CREATE TABLE t (
    id INT PRIMARY KEY,
    val VARCHAR(10)
);
INSERT INTO t VALUES (1, 'a'), (5, 'b'), (10, 'c');
```

事务操作：

```sql
-- 时间轴 | 事务A                          | 事务B
--------------------------------------------------------------------
-- T1     | BEGIN;                        |
-- T2     | SELECT * FROM t               |
--        | WHERE id = 3 FOR UPDATE;      |
--        | -- 锁定间隙(1,5)               |
-- T3     |                               | BEGIN;
-- T4     |                               | SELECT * FROM t 
--        |                               | WHERE id = 4 FOR UPDATE;
--        |                               | -- 也锁定间隙(1,5)
-- T5     | INSERT INTO t VALUES (4);     |
--        | -- 等待事务B的间隙锁释放         |
-- T6     |                               | INSERT INTO t VALUES (3);
--        |                               | -- 等待事务A的间隙锁释放
-- T7     | ❌ DEADLOCK!                  | ❌ DEADLOCK!
```

#### 4.2 死锁原因

- 间隙锁不是互斥的，所以相同范围的间隙锁可以被两个事务同时得到
- 插入时需要获得插入意向锁，与已存在的间隙锁冲突
- 两个事务互相等待对方的间隙锁释放，形成循环等待

#### 4.3 间隙锁不互斥的原因

（这里确实说的只是间隙锁不互斥，而临键锁是互斥的）

- **设计目的**：防止幻读，而不是提供互斥访问

- **逻辑合理性**：多个事务防止同一区间插入数据，目标一致不冲突
- **性能考虑**：避免不必要的锁竞争，提高并发性能

具体场景：当两个事务需要对同一个范围内的数据进行查询时，利用不互斥的间隙锁，既可以保证数据不被修改，又减少了锁竞争

#### 4.4 解决方法

只能尽量避免，无法完全避免

- **使用索引**：可以减小锁的范围，否则全表扫描会导致全表间隙锁
- **控制事务大小**：保证事务尽量简短，尽早提交
