# 数据库事务的四大特性（ACID）以及隔离级别

## 一、四大特性（ACID）

数据库事务是访问并可能操作各种数据项的一个数据库操作序列

### 1. 原子性（Atomicity）

事务内包含的所有操作要么全部成功，要么全部失败回滚

**实现：undo log**

### 2. 一致性（Consistency）

一个事务执行前和执行后都处于一致性状态。例如：A和B进行转账操作，A有200块钱，B有300块钱；当A转了100块钱给B之后，他们2个人的总额还是500块钱，不会改变

**实现：其他3个特性共同实现一致性**

### 3. 隔离性（Isolation）

当多个用户并发访问数据库时，数据库为每个用户开启一个事务，多个并发事务之间要相互隔离。即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行

**实现：隔离级别+MVCC**

### 4. 持久性（Durability）

一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的

**实现：redo log**

## 二、隔离级别

### 1. 未提交读READ UNCOMMITTED）

一个事务可以查询到其他事务**未提交的修改**，导致两次读取的数据不一致，称为**脏读**

### 2. 提交读（READ COMMITTED）

一个事务可以查询到其他事务**已提交的修改**，导致两次读取的数据不一致，称为**不可重复读**（Oracle的默认隔离级别）

### 3. 可重复读（REPEATABLE READ）

一个事务可以查询到其他事务对**某个范围内数据的增加或删除**，导致两次读取的数据量不一致，称为**幻读**（**MySQL的默认隔离级别**）

至于产生这种现象的原因，可以简单的理解为：一个事务在进行**第一次查询操作后**，产生了一个数据库的快照。读时不是真正的在读数据库，而是读这个快照。这样做的目的是**解决不可重复读问题，并提高并发效率，但会造成一定的数据误差**

### 4. 串行化（SERIALIZABLE）

在读取每一行数据都加锁，所以可能导致大量的超时和锁争用问题

## 三、如何解决脏读、不可重复读、幻读

对于脏读和不可重复读，**提高隔离级别**即可

对于幻读，如果再提高隔离级别，会大大降低性能，所以可以采用以下方案解决：

- **MVCC**：通过快照读保证一致性视图
- **间隙锁（Gap Lock）**：锁定索引记录之间的间隙，防止插入
- **临键锁（Next-Key Lock）**：记录锁 + 间隙锁的组合

## 四、MVCC工作原理

### 1. 简介

MVCC（Multi-Version Concurrency Control）多版本并发控制，是用来在数据库中控制并发的方法

**作用**：

- 解决脏读和不可重复读的问题
- 实现不加锁的读取，保证读写不冲突，提高并发性能

在MySQL中，MVCC只在提交读（Read Committed）和可重复读（Repeatable Read）两个隔离级别下有效，其是通过**ReadView一致性视图**和**Undo日志中的版本链**来实现的

### 2. ReadView

当事务执行快照读时，会生成一个ReadView，相当于给事务一个'数据快照'。它记录四个关键信息：

1、本事务的ID

2、活跃事务的ID列表（m_ids）：活跃事务即未提交的事务

3、最小活跃事务ID（min_trx_id）

4、下一个要分配的事务ID（max_trx_id）

### 3. 版本链

每行数据都有隐藏的DB_TRX_ID（最近修改的事务ID）和DB_ROLL_PTR（指向undo log中旧版本的指针）

每次修改时，InnoDB不是直接覆盖，而是将旧版本写入undo log，形成版本链。这就像一个链表，最新版本在表里，历史版本在undo log中

### 4. 可见性判断流程

当读取一行时，从最新版本开始遍历版本链，对于当前行的版本trx_id（即DB_TRX_ID）：

- 如果trx_id < min_trx_id → 这个版本在ReadView创建前已提交 → 可见

- 如果trx_id在m_ids中 → 这个版本由未提交事务创建 → 不可见

- 如果trx_id >= max_trx_id → 这个版本在ReadView之后才创建 → 不可见

- 如果trx_id = 当前事务ID → 自己修改的 → 可见

### 5. 常见问题

#### 5.1 MVCC在不同隔离级别的差异

即ReadView在不同隔离级别的创建时机是有区别的：

- **提交读**：每次SELECT都创建新ReadView，所以能看到最新提交的数据
- **可重复读**：只在第一次SELECT时创建ReadView，整个事务都使用这个快照（除非事务内有修改）

#### 5.2 MVCC能解决幻读吗？

标准MVCC本身不能完全解决幻读，因为新增的行没有历史版本

而MySQL的InnoDB在可重复读级别下，通过**间隙锁**配合MVCC解决了幻读问题，具体的：

- 针对**快照读**（普通 select 语句），是通过纯MVCC方式解决幻读（无需加锁）
- 针对**当前读**（select ... for update 等语句），是通过MVCC + 间隙锁方式解决幻读

#### 5.3 MySQL完全避免幻读了吗？

**没有，仍存在特殊场景存在幻读，比如快照读 + 当前读/update的混合使用**：

```sql
-- 事务A
START TRANSACTION;

-- 步骤1：快照读（无锁，使用MVCC）
SELECT * FROM users WHERE age > 20;
-- 返回：id=1(age=25), id=2(age=30)

-- 事务B此时插入并提交
-- INSERT INTO users (id, age) VALUES (3, 22);
-- COMMIT;

-- 步骤2：当前读（加锁）
SELECT * FROM users WHERE age > 20 FOR UPDATE;
-- 现在会看到：id=1, id=2, id=3
-- 因为FOR UPDATE会读取最新提交的数据并加锁

-- 步骤3：再次快照读
SELECT * FROM users WHERE age > 20;
-- 仍然看到：id=1, id=2（MVCC快照）
-- 但是步骤2已经看到了id=3，这就是幻读！
```

对于写操作，如update、insert，实际上都会先进行一次当前读，所以将步骤二的当前读改为update也会产生幻读

**解决方式**：关键场景统一使用当前读预先加锁

#### 5.4 MVCC可能遇到什么问题？

长事务可能导致undo log过大，但undo log有大小限制和清理机制，如果undo log满了，会阻止新事务开始，直到空间释放

#### 5.5 MVCC和锁有什么关系？

MVCC主要用于无锁的读操作，但写操作仍然需要加锁（如行锁）

两者协同工作：MVCC优化了读并发，锁机制保证了写一致性

