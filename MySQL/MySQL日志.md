# MySQL日志

## 一、 日志详细介绍

### 1. Binlog (归档日志/二进制日志)

**1. 所属层级**：MySQL Server 层（所有存储引擎共用）。

**2. 作用**：

- **主从复制 (Replication)**：从库通过读取主库的 binlog 来同步数据。
- **数据恢复 (Recovery)**：使用 `mysqlbinlog` 工具可以将数据恢复到某个特定的时间点 (Point-in-Time Recovery)。

**3. 存储内容 & 示例**：

- **内容**：逻辑日志。它是**追加写**（Append-only）的。
  - Statement格式：记录的是 SQL 语句
  - Row格式：记录数据行的变更详情

- **示例**：
  - Statement 格式：记录 `UPDATE t SET a=1 WHERE id=2;`
  - Row 格式：记录 "Table t, id 2, column a changed from 0 to 1"。
- **对比**
  - Row相比Statement更能保证数据的完整性（Statement无法记录函数或者触发器等情况），但所需空间更大。由于现代机器存储空间的增加，在MySQL5.7.7版本后，Row为默认格式
  - 存在 Mixed 格式，即两种格式的组合，由系统判断哪些情况选用哪种格式，但用处不大


**4. 持久化时机 (何时写盘)**：

- 事务提交时写入。
- 由参数 `sync_binlog` 控制：
  - `0`：交给操作系统控制（高性能，不安全）。
  - `1`：每次事务提交都强制 fsync 写入磁盘（最安全，推荐）。
  - `N`：每 N 个事务提交写一次。

**5. 清除时机**：

- **过期删除**：根据配置的过期时间（`binlog_expire_logs_seconds`）自动清理。
- **容量满删除**：根据配置的总大小（`max_binlog_size`）自动清理。

### 2. Redo Log (重做日志)

**1. 所属层级**：InnoDB 存储引擎层（特有）。

**2. 作用**：

- **保证事务的持久性**：即使数据库发生宕机（Crash），只要 redo log 在，重启后就能通过重放日志恢复未刷入磁盘的脏页数据。

**3. 存储内容 & 示例**：

- **内容**：物理日志。记录的是“在某个数据页（Page）上做了什么修改”。
- **示例**：
  - 类似：“Space ID 10, Page Number 5, Offset 20, Value changes from A to B”。

**4. 持久化时机**：

  - **预写日志 (WAL - Write-Ahead Logging)**：先写日志，再写数据。
  - 由参数 `innodb_flush_log_at_trx_commit` 控制：
    - `0`：每秒写入磁盘一次（进程挂了会丢数据）。
    - `1`：每次事务提交都写入磁盘（最安全）。
    - `2`：每次提交写入 OS Cache，由 OS 每秒刷盘（MySQL 挂了不丢，OS 挂了会丢）。

**5. 清除时机**：

- **循环写**：Redo log 文件组是固定大小的循环缓冲区（Circular Buffer）。当对应的数据脏页已经真正刷入磁盘后，旧的 redo log 空间就会被标记为可覆盖，从而被“清除/复用”。

### 3. Undo Log (回滚日志)

**1. 所属层级**：InnoDB 存储引擎层。

**2. 作用**：

- **保证事务的原子性**：如果事务执行失败，利用 undo log 将数据回滚到事务开始前的状态。
- **保证事务的隔离性**：为MVCC提供实现基础，查询时如果记录被加锁，可以通过 undo log 链找到历史版本（快照读）。

**3. 存储内容 & 示例**：

- **内容**：逻辑日志（反向操作）。
- **示例**：
  - 执行 `INSERT`，undo log 记录对应的 `DELETE`。
  - 执行 `UPDATE a=1` (原值0)，undo log 记录 `UPDATE a=0`。
  - 执行 `DELETE`，undo log 记录对应的 `INSERT`。

**4. 持久化时机**：

- **注意**：Undo log 的产生本身也会产生 Redo log，因此Undo log 也受 Redo log 的持久化保护。
- 事务执行过程中产生Undo Log，对应的Redo Log落盘后，由后台线程再写入Undo Log。

**5. 清除时机**：

- **事务提交后**：INSERT语句，因为INSERT对其他事务不可见，不需要等MVCC
- **MVCC不需要后**：UPDATE和DELETE语句，旧版本数据可能被其他事务快照读

## 二、 常见问题

### 1. 逻辑日志与物理日志的区别

虽然 Row 格式记录的是“每一行数据的变更细节”（例如：把 ID 为 3 的行，字段 A 从 10 改为 20），看起来比 SQL 语句更“底层”，但它依然是**逻辑日志**。

- **物理日志 (Physical Log)**：特指 **Redo Log**。它记录的是“数据页（Page）”上的物理修改（例如：在第 5 号页面的偏移量 100 处写入了什么字节）。
- **逻辑日志 (Logical Log)**：Binlog（包括 Row 格式）和Undo Log。因为它记录的是SQL语句或数据行的内容变更，不涉及物理存储位置（Page/Offset）。

### 2. Redo Log 与 Binlog 的区别（能否用 Redo Log 进行主从复制？）

**主要区别：**

| **特性**     | **Redo Log**                  | **Binlog**                        |
| ------------ | ----------------------------- | --------------------------------- |
| **产生位置** | InnoDB 引擎层                 | MySQL Server 层                   |
| **记录内容** | **物理日志** (数据页的修改)   | **逻辑日志** (SQL 语句或行数据)   |
| **写入方式** | **循环写** (固定大小，会覆盖) | **追加写** (文件只会增加，不覆盖) |
| **主要用途** | 崩溃恢复 (Crash Safe)         | 主从复制、数据恢复                |

**能否用 Redo Log 进行主从复制？**

**不能。** 原因如下：

- **循环覆盖**：Redo log 是循环写的，写满后会覆盖旧日志。如果从库同步较慢，主库旧的 redo log 可能已经被覆盖，导致同步中断。
- **物理格式依赖**：Redo log 记录的是物理页的修改，这要求主从库的底层物理存储结构（Page 结构、大小等）完全一致。而 Binlog 是逻辑的，兼容性更好。

### 3. Redo Log 与 Undo Log 的区别

虽然它们都叫 log，但方向完全相反：

- **Redo Log (前滚)**：记录“新数据是什么”。用于**恢复**已提交但未写入磁盘的数据。它保障了**持久性**。
- **Undo Log (回滚)**：记录“旧数据是什么”。用于**回滚**未提交的事务或提供多版本读。它保障了**原子性**。

### 4. 为什么要先将 Redo Log 写入磁盘，再将数据写入磁盘？

这是 **WAL (Write-Ahead Logging)** 技术的核心思想，主要基于以下两个原因：

1. **性能优化 (顺序写 vs 随机写)**：
   - 写 Redo log 是磁盘**顺序写**（追加到日志文件末尾），速度非常快。
   - 直接将数据写入磁盘（刷脏页）通常是**随机写**（数据分散在不同磁盘页上），速度慢。
   - 先写日志可以极大地提高事务提交的响应速度。
2. **数据安全 (Crash Safe)**：
   - 只要日志写入成功，事务就被视为成功。即使后续刷脏页时系统宕机，重启后依然可以通过 Redo log 重做，保证数据不丢失。

### 5. Redo Log 能否完全保证数据不丢失？

**不一定，取决于配置和硬件。**

1. **参数配置**：只有当 `innodb_flush_log_at_trx_commit = 1` 时，才能保证每次事务提交，Redo log 都真正落盘。如果设置为 0 或 2，在断电或系统崩溃时，可能会丢失 1 秒左右的数据。
2. **双 "1" 配置**：为了由于 Redo Log 和 Binlog 的两阶段提交机制，通常要求 `sync_binlog = 1` 和 `innodb_flush_log_at_trx_commit = 1` 同时开启，才能最大限度保证数据一致性和不丢失。
3. **硬件故障**：如果磁盘本身发生了物理损坏（坏道、控制器故障），单纯靠软件层面的 Redo log 也是无法恢复的（此时需要 RAID 或备份）。