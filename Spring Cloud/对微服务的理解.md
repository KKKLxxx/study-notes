# 对微服务的理解

## 一、单体应用

所谓单体应用是指所有的模块、业务都包含在一个应用中，比如用户管理模块、内容管理模块、推送模块全部放在一个应用中，发布时打成一个独立的包，放到Web容器中

### 单体应用的优势

**部署方便**，如果规模不大的话，开发测试也比较方便

### 单体应用的劣势

1、**复杂度高导致可维护性低**： 随着需求的增加，项目规模开始膨胀，对象间的依赖关系变得复杂，编译以及测试度秒如年，调试起来也不再轻松。随着时间的推移和人员的更迭，不同的代码风格交织在一起，可维护性变得越来越低

2、**发布频率低导致发布风险高**： 虽然单体应用易于部署，但因为每次发布都需要重新部署整个应用，中断所有服务，为了减少中断的时间不得不降低发布频率，因此两次发布之间可能有大量的变更，导致发布风险比较高

3、**可靠性低**： 所有模块共享一个进程，某个模块的bug可能导致整个应用瘫痪

4、**扩展灵活度低**： 无法根据不同的业务需求选择不同的硬件规格进行部署，比如IO密集型的模块需要更大的内存，计算密集型的模块需要更快的CPU

5、**技术栈受限**： 单体应用的语言、框架通常是统一的，如果希望不同模块用不同的语言、框架做是比较困难的，比如用户模块用Java，推送模块用Go

## 二、什么是微服务

微服务和单体应用恰恰相反，把各个模块拆分成不同的项目，每个模块都只关注一个特定的业务功能，发布时每一个项目都是一个独立的包，运行在独立的进程上。微服务应该足够小，小到即使全部重写也不需要过多的时间

### 微服务的优势

1、**易于开发，可维护性高**： 一个服务只会关注一个特定的业务模块，代码比较少，可维护性就高

2、**发布风险低**： 发布单个服务不需要重新发布整个应用

3、**技术栈不受限**： 微服务之间通过轻量级的通信机制进行通信，比如RESTful API，因此不同项目可以随意选择合适的技术来实现

4、**按需伸缩**： 可以针对特定的服务，结合业务特点分配不同的硬件规格

### 微服务的劣势

1、**运维要求高**： 对于单体应用只要部署一个服务，微服务化后可能需要部署几十个服务

2、**重复劳动**： 当一个单体应用微服务化后，不同的服务之间会有重复代码产生，比如Gradle脚本、Maven依赖都非常类似，使用到的某些函数每个服务都造了一遍等，如果都是用同一种语言实现的还能用共享库解决，如果有多种语言那就难以避免重复劳动了

## 三、微服务设计原则

### 单一职责

每个服务应该只关注特定的某一类业务

### 服务自治

每个服务具备独立的业务能力、依赖和运行环境，与其他服务高度解耦，每个服务都应当可以独立运行，不应该依赖其他服务

### RESTful风格

1、**接口统一**：由于接口仅包括URI，所以相对统一，不会出现混乱的命名规则

2、**服务自解释**：比如对于一个订单的URI，通过操作方式即可大概得知操作效果，比如get(查看订单)，post(提交订单)，put(更新订单)，delete(删除订单)

