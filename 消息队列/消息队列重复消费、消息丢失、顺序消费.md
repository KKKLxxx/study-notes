# 消息队列重复消费、消息丢失、顺序消费

## 重复消费

### 原因

通常消息被成功消费后消费者都会发送一个成功标志给MQ，MQ收到这个标志就表示消息已经成功消费了，就不会再发送给其他消费者了。 但是如果因为网络这个标志没有送到MQ就丢失了，MQ就认为这个消息没有被成功消费，就会再次发送给其他消费者消费，就造成重复了

### 解决方案

可以以某种算法对每个消息生成一个ID，再通过Redis存储已消费消息的ID。每次要消费消息时，都要先在Redis中查询是否消费过，如果没有这条记录才可以消费。这种方法在单机环境中比较容易实现，在多机环境下，还涉及到分布式事务

## 消息丢失

### 原因及解决方案

消息传递涉及3个部分，生产者->MQ->消费者，这三者都有可能出问题导致消息丢失

**生产者丢失消息**：指的是因为网络等问题，消息并没有传到MQ。这时候可以采用确认机制，当MQ收到消息并回复一个ACK后才能消息传递成功，否则生产者要超时重传

**MQ丢失消息**：这种情况可以通过开启每种MQ的持久化机制解决

**消费者未接收到消息或者消费失败**：也可以通过ACK机制解决，只有当消费者成功消费后才回复ACK。有些MQ采用自动确认，如果为了保险，可以采用手动确认机制

## 顺序消费

有些场景是需要保证顺序消费的，比如数据库的增删，要先增再删，而不能反过来。如果要保证顺序消费，往往就是要保证生产者、MQ、消费者一一对应。对于RabbitMQ，要保证Producer->Exchange->Queue->Consumer只存在一条线；对于Kafka，要保证Producer->Topic(Partition)->Consumer只存在一条线

