# TCP三次握手与四次挥手

## 一、三次握手

<img src="https://raw.githubusercontent.com/KKKLxxx/img-host/master/GSygpdRW2KO4Xl6.jpg" style="zoom:80%;" />

### 1、三次挥手的过程

1、client向server请求连接（SYN）

2、server同意client的连接（SYN+ACK）

3、client向server确认连接（ACK）

SYN相当于一个申请建立连接的信号，ACK相当于一个确认建立连接的信号

**第三次握手是可以携带数据的，前两次握手是不可以携带数据的**

### 2、为什么不能只进行两次握手？

**防止已失效的连接请求突然又传送到了服务端，导致重复建立连接**

“已失效的连接请求”的产生在这样一种情况下：

1、client发出的第一个连接请求A并没有丢失，而是在某个网络节点长时间滞留了，超时后client发出了新的连接请求B

2、此时A恢复传输，比B先到达server，server生成应答回复client

3、client收到连接请求A的应答，但该应答的确认号与自己期待的不同，所以会回RST报文，释放旧的连接

如果没有第三次握手，那么server会误以为连接已经建立了，并等待client发来数据，这样资源就浪费掉了

### 3、为什么不需要四次握手？

因为三次握手已经能够建立可靠的连接，无需更多的通信次数

### 4、为什么每次建立TCP连接时，初始化的序列号都要求不一样？

**为了防止历史报文被下一个相同四元组的连接接收**

假设client与server因断电等原因在短时间内建立了两次连接（而没有通过正常的挥手流程释放，否则旧报文直接失效），若序列号相同，则第二次连接中很有可能接收到第一次连接中的旧报文（数据报文），并且该旧报文在对方的接收窗口内，从而导致错误

### 5、握手丢失会发生什么？

简单来说，不管是第几次握手丢失，都会根据系统设定的进行一定次数的重传（指数增长间隔）

### 6、SYN攻击

SYN攻击是客户端通过伪造IP地址，向服务器发送大量的SYN报文，使得服务器回应后，一直无法得到第三次握手回应，半连接队列中保留了大量不正常的连接，导致无法与正常用户建立新的连接

解决方法：

1、增大半连接队列的容量

2、减少第二次握手的重传次数，尽快释放半连接

### 7、已建立连接的TCP，收到SYN会发生什么？

1、**客户端通过不同端口号请求连接**

因为四元组不同，所以会重新建立一个连接，旧连接会在Keepalive的机制下断开

2、**客户端通过相同端口号请求连接**

与“为什么不能只进行两次握手？”的答案相同，即会返回RST释放旧的连接

## 二、四次挥手

<img src="https://raw.githubusercontent.com/KKKLxxx/img-host/master/xfYn7Jh68C2uIjM.jpg" style="zoom:80%;" />

### 1、四次挥手的过程

1、主机A向主机B申请断开连接（FIN）

2、主机B同意主机A的断开连接请求（ACK）

3、主机B向主机A申请断开连接（FIN）

4、主机A确认断开连接（ACK），发送完后主机A进入TIME_WAIT状态，等待2MSL（报文最大生存时间）

### 2、为什么主机B的ACK和FIN要分两次传输

因为主机B回传ACK只表示主机B同意断开连接，但并不等于现在就可以断开连接，因为主机B可能还有未发送完的消息，等主机B发送完了所有消息，才能够传FIN

### 3、第二三次挥手能不能合并？

可以，当没有数据要发送，并且开启了“延迟确认”机制时（否则ACK会立即单独发送），可以合并成一个ACK+FIN一起发送

延迟确认：为了避免单独回传一个ACK，可以等到有响应数据发送时一起回传ACK，反之是“快速应答”模式

### 4、为什么TIME_WAIT状态必须等待2MSL

1、**使本次连接所产生的所有报文段都从网络中消失**

这样就可以使下一个新的连接中不会出现旧的连接请求的报文段（但这只需要1MSL）

2、**保证主机A发送的最后一个ACK报文能够到达主机B**

如果A在TIME_WAIT状态不等待一段时间并且ACK丢失，就无法收到B重传的FIN，因而也不会再发送一次ACK，这样B就无法按照正常的步骤进入CLOSED状态（这里才需要2MSL，因为第四次挥手和重传的第三次挥手一共需要2MSL）

### 5、有大量处于TIME_WAIT状态的连接会怎样？

1、**客户端有大量处于TIME_WAIT状态的连接**

说明是客户端主动断开连接，会导致端口和文件描述符等系统资源占用过多。并且若端口占满，则会导致客户端无法再与同目的IP/端口的服务器建立连接（因为四元组确定一个TCP连接）

2、**服务端有大量处于TIME_WAIT状态的连接**

说明是服务端主动断开连接，会导致端口和文件描述符等系统资源占用过多。但不会因为端口限制其他客户端的连接（并且服务端基本也就只用80端口），但仍要考虑文件描述符等的限制

3、**发生原因**

没有使用长连接时，会大量创建并释放TCP连接

4、**如何优化**

1、使用长连接

2、允许处于TIME_WAIT状态的连接用于新的连接

3、减少MSL以减少等待时间

### 6、建立连接后，进程崩溃/机器宕机会怎样？

**进程崩溃**：内核会回收进程资源，并发送FIN进入挥手流程，或者发送RST强制断开

**机器宕机**：利用TCP的保活机制（KeepAlive，不同于HTTP的keep-alive），通过心跳包探测对方是否存活，如果连续多个心跳包没有响应，则会释放连接
