# TCP、UDP、IP

## 一、TCP与UDP对比

|                  | TCP                | UDP                                       |
| ---------------- | ------------------ | ----------------------------------------- |
| **是否面向连接** | 面向连接           | 无连接                                    |
| **可靠性**       | 可靠               | 不可靠                                    |
| **传输形式**     | 字节流（导致粘包） | 报文                                      |
| **传输速度**     | 慢                 | 快                                        |
| **所需资源**     | 多                 | 少                                        |
| **应用场景**     | 可靠性要求大于时延 | 时延要求大于可靠性，如直播、语音、**DNS** |

## 二、TCP如何保证传输可靠

**校验和**

**序号、确认应答ACK**：保证顺序传输、解决丢包

**超时重传**：重传计时器

**连接管理**：建立连接需要3次握手，释放连接需要4次挥手

**流量控制**：由接收方主导，通过发送接收窗口向发送方反馈接受能力，防止接收方缓冲区溢出，主要考虑的是各端之间的发送、接收处理能力。通过滑动窗口控制，Nagle算法避免发送方发送小包（积累足够的数据后再一起发送），Clark算法解决接收方通告小接收窗口导致发送方发送小数据包的问题（等到缓冲区足够大时才反馈接收窗口）

**拥塞控制**：由发送方主导，通过主动探测丢包情况并调整拥塞窗口，降低网络的负载，是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。用慢启动+拥塞避免（AIMD，加性增，乘性减）+快重传（3个重复ACK）等机制维护拥塞窗口

## 三、使用TCP就能保证完全可靠传输了吗？

不能，因为TCP只能保证在传输层及以下层的可靠传输，应用层与传输层之间仍有可能发生消息丢失、乱序的问题

需要在应用层做额外的校验等方式保证传输可靠，比如服务器与客户端进行最新消息的id对比

## 四、如何实现UDP可靠传输

在应用层实现校验、确认、重发、拥塞控制、流量控制等功能（HTTP/3.0的QUIC协议）

## 五、TCP报文结构

### 1、TCP报文格式图示

![](https://raw.githubusercontent.com/KKKLxxx/img-host/master/9sfJzAGElKHe5ai.jpg)

### 2、固定头部各字段解释

**【源端口】- 16bit**

　　来源处的端口号；端口号有65536个

**【目的端口】- 16bit**

​		目的处的端口号

**【序号】- 32bit**

　　TCP是面向连接的可靠服务，这个序号可以保证数据在传输过程中保持有序性，接受端可以通过这个序号确认收到的数据的完整性和先后顺序

**【确认号】- 32bit**

　　确认号，是期望收到对方的下一个报文段的数据的第一个字节的序号

**【数据偏移】- 4bit**

　　指TCP报文段的数据部分的起始处距离TCP报文段的起始处的距离

**【保留字段】- 6bit**

　　IETF文档指出，这6bit在标准中是保留字段，留待以后使用，必须为0。我猜测，有两个目的，第一个是预留除URG/ACK/PSH/RST/SYN/FIN之外的冗余功能位；第二个是为了对齐字节位。

**【控制位】- 6bit**

　　**① 紧急字段URG - 1bit**

　　　　当URG=1时，此字段告诉系统此报文段中有紧急数据，应尽快传送

　　**② 确认字段ACK - 1bit**

　　　　当ACK=1时，表示确认，且确认号有效；当ACK=0时，确认号字段无效

　　**③ 推送字段PSH - 1bit**

　　　　当PSH=1时，则报文段会被尽快地交付给目的方，不会对这样的报文段使用缓存策略

　　**④ 复位字段RST - 1bit**

　　　　当RST为1时，表明TCP连接中出现了严重的差错，必须释放连接，然后再重新建立连接

　　**⑤ 同步字段SYN - 1bit**

　　　　当SYN=1时，表示发起一个连接请求

　　**⑥ 终止字段FIN - 1bit**

　　　　用来释放连接。当FIN=1时，表明此报文段的发送端的数据已发送完成，并要求释放连接

**【窗口字段】- 16bit**

　　此字段用来控制对方发送的数据量，单位为字节

**【校验和字段】- 16bit**

　　与IP协议的检验和不同，TCP的这个校验和是针对首部和数据两部分的

**【紧急指针字段】- 16bit**

　　紧急指针指出在本报文段中的紧急数据的最后一个字节的序号

### 3、可选头部各字段解释

　　在TCP报文头部的前20个字节是固定的。有时TCP报文也会在报文头部增加一些选项，该部分的长度不固定，不同的应用场景会有所变化。

　　该部分的可选项常用的包含但不仅限于有以下几种：

　　① 最大报文传输段（即常提到的MSS）: 用于确定每一个TCP报文段中科传输的最大的数据长度（注意，不包括头部）

　　② 窗口扩大选项：TCP的窗口大小最大为64K，在大多数时候这是够用的，但有时候为了提高吞吐量，就需要对窗口扩大，这个时候，就需要使用该选项对窗口进行扩大。

　　③ 时间戳选项:可以用来计算RLL，进而可以用于TCP的拥塞控制。

### 4、一个TCP包中数据最长为多少/MTU与MSS

TCP包数据长度**MSS**受到三方面限制：**MTU**长度、**IP报文头部**长度、**TCP报文头部**长度。

MTU（Maximum Transmission Unit，最大传输单元）一般为1500字节，**过长的话数据发送间隔过长，过短的话传输效率低**

IP报文头部长度在20-60字节之间，20字节之后为可选字段

TCP报文头部与IP类似，一般为20字节

**经典公式**：`MSS = MTU - IP头大小（20字节） - TCP头大小（20字节）`

所以一个TCP包中数据部分长度最长为**1460字节**

| 特性         | **MTU（Maximum Transmission Unit，最大传输单元）** | **MSS（Maximum Segment Size，最大报文段长度）**      |
| :----------- | :------------------------------------------------- | :--------------------------------------------------- |
| **所属层次** | **数据链路层** (L2)                                | **传输层** (L4)，**TCP特有**                         |
| **定义对象** | 单个**数据帧**的最大尺寸                           | 单个**TCP报文段**中**应用数据**的最大尺寸            |
| **包含内容** | **L2帧头 + IP头 + TCP头 + 数据**                   | 仅指 **数据**（不含TCP/IP头）                        |
| **决定者**   | 物理网络标准、网卡、路由器接口                     | 由通信双方在TCP握手时**协商**确定，基于各自的MTU计算 |
| **主要目的** | 定义物理网络的承载能力                             | **避免IP分片**，优化TCP传输效率                      |
| **典型值**   | 以太网：1500字节                                   | 在MTU=1500时：1460字节                               |

## 六、UDP报文结构

每个 UDP 报文分为 UDP 报头和 UDP 数据区两部分。报头由 4 个 16 位长（**2 字节**）字段组成，分别说明该报文的源端口、目的端口、报文长度和校验值。

### 1、UDP报文格式图示

![](https://raw.githubusercontent.com/KKKLxxx/img-host/master/nq2FGTjKoIvAwb5.gif)

### 2、固定头部的各字段解释

- 源端口
- 目的端口
- 长度：该字段占据 16 位，表示 UDP 数据报长度，包含 UDP 报文头和 UDP 数据长度。因为 UDP 报文头长度是 8 个字节，所以这个值最小为 8
- 校验值：该字段占据 16 位，可以检验数据在传输过程中是否被损坏

### 3、TCP与UDP可以使用同一个端口吗？

可以，因为它们是完全独立的两个协议，一个连接由 **五元组** 唯一标识：

```
(源IP, 源端口, 目标IP, 目标端口, 传输协议)
```

其中 **传输协议** 就区分了 TCP 和 UDP

当数据包到达时，操作系统会根据 **IP 头部中的"协议"字段** 来决定将数据交给哪个协议栈处理：

```c
// IP头部中的协议字段
- 协议值 6: 交给 TCP 协议栈处理
- 协议值 17: 交给 UDP 协议栈处理

// 然后各自协议栈内部根据端口号分发到对应的应用程序
TCP: IP(协议=6) + TCP头(端口=80) → TCP端口80的应用程序
UDP: IP(协议=17) + UDP头(端口=80) → UDP端口80的应用程序
```

## 七、IP报文结构

### 1、IP报文格式图示

<img src="https://raw.githubusercontent.com/KKKLxxx/img-host/master/TrxYELhGgjkVze9.png" alt="在这里插入图片描述" style="zoom: 80%;" />

TCP与UDP报文包含着IP报文

### 2、固定头部的各字段解释

版本：ipv4/ipv6
