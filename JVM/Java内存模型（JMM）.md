# Java内存模型（JMM）

**首先要区分两个概念**

1、Java内存区域（Java运行时数据区域），描述的是堆、栈等区域的划分

2、Java内存模型（JMM），用来屏蔽各种硬件和操作系统的内存访问差异，以实现Java程序在各种平台都能达到一致的内存访问效果

## 一、概念

正如上文所说，Java内存模型是用来**屏蔽各种硬件和操作系统的内存访问差异，以实现Java程序在各种平台都能达到一致的内存访问效果**的一个模型

## 二、Java内存模型具体内容

### （一）主内存与工作内存

<img src="https://raw.githubusercontent.com/KKKLxxx/img-host/master/20210904154311719.png" style="zoom:50%;" />

**主内存**：用于**存储所有的变量**

**工作内存**：每条线程还有自己的工作内存，线程的工作内存中**保存了被该线程使用的变量的主内存副本**，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成

主内存与工作内存的关系类似于内存与高速缓存，工作内存的存在**提高了程序的运行速度**

### （二）内存间交互操作

简单来说，就是定义了对于所有变量，有以下4种操作是**原子性**的（详细来讲有8种，但可以精简为4种）

1、**lock（锁定）**：作用于主内存的变量，它把一个变量标识为一条线程独占的状态

2、**unlock（解锁）**：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定

3、**read（读取）**：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中

4、**write（写入）**：作用于主内存的变量，它把从工作内存中得到的变量的值放入主内存的变量中

### （三）对于long和double的特殊规则

因为long和double是64位的，所以允许将这两种类型的数据的读写操作划分为两次32位的操作来进行，即**对于long和double，read和write是不保证原子性的**

但是在实景情况中，这种非原子性出现的概率也较小，所以除非该数据有明确可知的线程竞争，否则我们在编写代码时一般不需要因为这个原因刻意把用到的long和double变量专门声明为volatile

### （四）volatile变量

volatile保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。当一个变量被定义成volatile之后，它将具备两项特性

1、**保证此变量对所有线程的可见性**：指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成

这里的一个**常见误区**是：只要一个变量用volatile修饰，那么这个对于这个变量的所有操作就是线程安全的

在多线程情况下，多个线程对同一个volatile进行自增操作，如a++，则实际情况可能与预期不符。因为a++实际上包含至少三个操作：读取a的旧值，将a递增，将a的新值写回主内存。volatile并不保证这三个操作之间不会被打断，所以可能出现的一种情况是：当线程A读取a的旧值并递增之后，线程B又读取了a的旧值，递增并写回主内存，之后线程A继续执行写回主内存的操作，导致a递增了2次但只增加了1

2、**禁止指令重排序优化**：在单线程环境下，编译器和处理器为了提高运行速度，会在不影响运行结果的前提下对指令进行重排序。而在多线程环境下，这种重排序就会造成错误的结果。JMM通过在修改volatile变量之后插入一个**内存屏障**，来禁止重排序时内存屏障之后的指令被重排序到内存屏障之前，保证被修改的volatile变量立即对其他线程可见

### （五）JMM三大特性

1、**原子性**：一个操作要么执行了就不会被打断要么不执行。实现方式：synchronized，其他锁操作

2、**可见性**：指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。实现方式：volatile，synchronized

3、**有序性**：指解决“工作内存与主内存同步延迟”现象和“指令重排序”现象。实现方式：volatile，synchronized

### （六）Happens-Before原则（先行发生规则）

Happens-Before是Java内存模型中定义的两项操作之间的偏序关系，比如说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等

如果两个操作满足以下关系中的任意一种，就可以保证有序性，否则虚拟机可以对它们随意地进行重排序

1、**程序次序规则**：在一个线程内，书写在前面的操作先行发生于书写在后面的操作

2、**管程锁定规则**：一个unlock操作先行发生于后面对同一个锁的lock操作

3、**volatile变量规则**：对一个volatile变量的写操作先行发生于后面对这个变量的读操作

4、**传递性**：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论

一共8种，以上仅为重要的4种

下面用一个例子来深入理解下这4个规则

```java
private int value = 0;

pubilc void setValue(int value) {
    this.value = value;
}

public int getValue() {
    return value;
}
```

代码中显示的是一组再普通不过的getter/setter方法，假设存在线程A和B，线程A先（时间上的先后）调用了setValue(1)，然后线程B调用了同一个对象的getValue()，那么线程B收到的返回值是什么？

我们依次分析一下先行发生原则中的各项规则。由于两个方法分别由线程A和B调用，不在一个线程中，所以程序次序规则在这里不适用；由于没有同步块，自然就不会发生lock和unlock操作，所以管程锁定规则不适用；由于value变量没有被volatile关键字修饰，所以volatile变量规则不适用；后面的线程启动、终止、中断规则和对象终结规则也和这里完全没有关系（就是上面省略的4个规则）。因为没有一个适用的先行发生规则，所以最后一条传递性也无从谈起，因此我们可以判定，尽管线程A在操作时间上先于线程B，但是无法确定线程B中getValue()方法的返回结果，换句话说，这里面的操作不是线程安全的

那怎么修复这个问题呢？我们至少有两种比较简单的方案可以选择：要么把getter/setter方法都定义为synchronized方法，这样就可以套用管程锁定规则；要么把value定义为volatile变量，由于setter方法对value的修改不依赖value的原值，满足volatile关键字使用场景，这样就可以套用volatile变量规则来实现先行发生关系