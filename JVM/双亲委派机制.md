# 双亲委派机制

## 一、类加载器

Java源代码被编译器编译成`.class`的字节码文件，然后由`ClassLoader`负责将这些`.class`文件给加载到JVM中去生成对应`Class`对象

`ClassLoader`分为4层：

- **BootstrapClassLoader（启动类加载器）**：核心类，`java.lang.*`

- **ExtClassLoader（扩展类加载器）**：`jre`等扩展类

- **AppClassLoader（应用程序类加载器）**：用户自己编写的类

- **CustomClassLoader（自定义类加载器）**：可选，如果没有自己编写“自定义类加载器”，则使用“应用程序类加载器”

<img src="https://raw.githubusercontent.com/KKKLxxx/img-host/master/20210905211802568.png" style="zoom:50%;" />

**类加载器之间不是继承关系**，它们只是通过一个`parent`字段来标识自己的父加载器

每个类加载器负责加载不同路径下的类，如启动类加载器负责加载`%JAVA_HOME%/lib`路径下的类，扩展类加载器负责加载`%JAVA_HOME%/lib/ext`路径下的类等

**不统一使用一个类加载器的原因**：为了实现类的隔离。因为一个服务器上可能运行着多个应用程序，每个应用可能有着名称相同但版本不同的依赖（类），如果各应用通过不同的类加载器进行加载，那么应用之间就不会互相影响

**补充**：JVM区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类

## 二、加载过程

类加载器在加载类时先委派给其父加载器，只有在父加载器无法找到类的情况下，子加载器才会尝试加载

**为什么要自底向上开始，不能直接由启动类加载器开始加载吗？**：因为类加载器只存储了自己的父加载器，而没有存储子加载器。所以为了避免重复加载，只能通过自底向上的传递，让父加载器检验是否加载过

**区分启动、扩展、应用程序类加载器的目的**：todo，网上没有特别好的解释

## 三、作用

1、**避免重复加载**：因为父加载器会缓存已经加载过的类，所以如果一个类已经被加载过，就会直接返回已加载的类

2、**保证核心类不被篡改**：因为核心类会先由顶层的启动类加载器加载，其他加载器会检测到这个类已经被加载过，就不会重复加载（比如如果自己实现一个`java.lang.Object`类，那么这个类不会被正常加载。如果想加载一个`java.lang.MyObject`类，会报错提示不允许使用`java.lang`这个包名）

## 四、破坏双亲委派机制

双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式。这个委派和加载顺序完全是可以被破坏的

如果想自定义类加载器，就需要继承`ClassLoader`，并重写`findClass()`，如果想不遵循双亲委派的类加载顺序，还需要重写`loadClass()`

### Tomcat为什么破坏双亲委派机制？

**为了实现类的隔离**：因为Tomcat是web容器，那么一个web容器可能需要部署多个应用程序。不同应用可能有着名称相同但版本不同的依赖（类），如果各应用通过不同的类加载器进行加载，那么应用之间就不会互相影响

假如多个应用都要依赖`hollis.jar`，但是A应用需要依赖`1.0.0`版本，但是B应用需要依赖`1.0.1`版本。这两个版本中都有一个类是`com.hollis.Test.class`。如果采用默认的双亲委派类加载机制，那么是无法加载多个相同的类的

所以，Tomcat破坏双亲委派原则，为每个web容器单独提供一个`WebAppClassLoader`加载器，优先加载web应用自己定义的类。每一个应用自己的类加载器`WebAppClassLoader`负责加载本身的目录下的`.class`文件，加载不了时再交给父加载器加载。但对于核心类和扩展类，Tomcat仍然通过双亲委派机制加载
