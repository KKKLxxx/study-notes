# 垃圾收集算法与垃圾收集器

## 一、为什么需要了解垃圾收集

垃圾收集（`Garbage Collection`，下文简称**GC**）。当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节

## 二、垃圾收集作用的区域

主要作用于“**堆**”。因为堆内存的使用具有很大的不确定性，只有处于运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的

ps：对于**方法区**，如果一些常量或者类不再使用，也可以被回收。但由于这些内容的回收性价比较低，所以并不要求一定要对方法区进行垃圾回收

## 三、判断对象是否需要回收的算法

### 1、引用计数算法（有缺陷）

顾名思义，通过一个引用计数器来统计一个对象的引用数，当引用数为0时说明该对象不会再被访问到，即可被回收。这个方法虽然简单，但是有一个致命缺陷：循环引用问题

举一个简单的例子

```java
public class Main {
    public static void main(String[] args) {
        testClass A = new testClass();
        testClass B = new testClass();

        A.value = B;
        B.value = A;

        A = null;
        B = null;
    }
}

class testClass {
    Object value;
}
```

刚创建A、B两个对象时，两者引用计数均为1；A、B两个对象相互引用，两者计数均增加为2；在将A、B赋值为`null`后，各减少了一次引用，所以最终引用计数各为1。但此时已经无法再访问到原对象了，理论上讲应该被回收，但是引用计数不为0，无法回收，这就是循环引用问题

### 2、可达性分析算法

这个算法的基本思路就是通过一系列称为“**`GC Root`**”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”，如果某个对象到`GC Root`间没有任何引用链相连，或者用图论的话来说就是从`GC Root`到这个对象不可达时，则证明此对象是不可能再被使用的

如图所示，对象`object 5`、`object 6`、`object 7`虽然互有关联，但是它们到`GC Root`是不可达的，因此它们将会被判定为可回收的对象

<img src="https://raw.githubusercontent.com/KKKLxxx/img-host/master/20210906212354456.png" style="zoom:50%;" />

在Java技术体系里面，固定可作为`GC Root`的对象包括以下几种：

1、**在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等**

2、**在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量**

3、在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用

4、在本地方法栈中JNI（即通常所说的`native`方法）引用的对象

5、Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如`NullPointExcepiton`、`OutOfMemoryError`）等，还有系统类加载器

6、**所有被同步锁（synchronized关键字）持有的对象**

7、反映Java虚拟机内部情况的`JMXBean`、`JVMTI`中注册的回调、本地代码缓存等

### 3、对象自救——finalize方法（了解即可）

即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段，要**真正宣告一个对象死亡，至少要经历两次标记过程**：如果对象在进行可达性分析后发现没有与`GC Root`相连接的引用链，那它将会被第一次标记，随后进行一次筛选，**筛选的条件是此对象是否有必要执行`finalize()`方法**。假如对象**没有覆盖`finalize()`方法**，或者**`finalize()`方法已经被虚拟机调用过**，那么虚拟机将这两种情况都视为“没有必要执行”

如果这个对象被判定为确有必要执行`finalize()`方法，那么该对象将会被放置在一个名为`F-Queue`的队列之中，并在稍后由一条由虚拟机自动建立的、**低调度优先级**的`Finalizer`线程去执行它们的`finalize()`方法

这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。这样做的原因是，如果某个对象的`finalize()`方法执行缓慢，或者更极端地发生了死循环，将很可能导致`F-Queue`队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃

如果对象要在`finalize()`中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了

通过一段代码来体验下`finalize()`方法

```java
public class FinalizeEscapeGC {
    public static FinalizeEscapeGC SAVE_HOOK = null;

    public void isAlive() {
        System.out.println("yes, i am still alive :)");
    }

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("finalize method executed!");
        FinalizeEscapeGC.SAVE_HOOK = this;
    }

    public static void main(String[] args) throws Throwable {
        SAVE_HOOK = new FinalizeEscapeGC();
        //对象第一次成功拯救自己
        SAVE_HOOK = null;
        System.gc();
        // 因为Finalizer方法优先级很低，暂停0.5秒，以等待它
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
            SAVE_HOOK.isAlive();
        } else {
            System.out.println("no, i am dead :(");
        }
        // 下面这段代码与上面的完全相同，但是这次自救却失败了
        SAVE_HOOK = null;
        System.gc();
        // 因为Finalizer方法优先级很低，暂停0.5秒，以等待它
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
            SAVE_HOOK.isAlive();
        } else {
            System.out.println("no, i am dead :(");
        }
    }
}

```

输出结果

```
finalize method executed!
yes, i am still alive :)
no, i am dead :(
```

可以看到对象第一次调用finalize自救成功，第二次便失败了，与上面所说的筛选条件相符

**但是`finalize()`方法应该避免使用，它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序，如今已被官方明确声明为不推荐使用的语法。了解即可**

## 四、垃圾回收算法

### 1、分代收集理论

当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”的理论进行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上：

**1）弱分代假说：绝大多数对象都是朝生夕灭的**

**2）强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡**

这两个假说使得Java堆在设计时也分为多个区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域中存储。Java堆中至少有**新生代**和**老年代**两个区域，新生代中的对象大多会在一次垃圾收集之后消亡，只有少量存活，这些存活的对象会逐步晋升至老年代

**根据新生代和老年代中对象的特点，可以分别采用不同的收集算法和收集频率，以达到最高的垃圾回收效率**。对新生代的垃圾回收称为**`Minor GC`**，对老年的垃圾回收称为**`Major GC`**，对整个堆的垃圾回收称为**`Full GC`**

**3）跨代引用假说：跨代引用相对于同代引用来说仅占极少数**

新生代的对象有可能被老年代所引用，比如

```java
public class Main {
    static HashSet<Object> set = new HashSet<>();
    public static void main(String[] args) {
        Object obj = new Object();
        set.add(obj);
        obj = null;
    }
}
```

`static HashSet`可以作为一个`GC Root`对象，即老年代；`obj`是一个普通对象，即新生代。将`obj`放入`set`中，使得`obj`总是存在一个到达`GC Root`的引用链，即使`obj`被赋值为`null`也不会被垃圾回收

为了解决跨代引用问题，不得不对老年代区域进行一次扫描，这样毫无疑问会降低效率。解决办法就是在新生代上建立一个全局的数据结构（该结构被称为“记忆集”，**`Remembered Set`**），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生`Minor GC`时，只有包含了跨代引用的小块内存里的对象才会被加入到`GC Root`进行扫描

### 2、标记-清除算法

这个算法顾名思义，先标记出需要被回收的对象（标记方法在“对象自救”中讲过），再清除

<img src="https://raw.githubusercontent.com/KKKLxxx/img-host/master/20210909204118422.png" style="zoom:50%;" />

后续的收集算法大多都是以标记-清除算法为基础，对其缺点进行改进而得到的。它的主要**缺点**有两个：

1、**执行效率不稳定**：如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低

2、**内存空间的碎片化问题**：标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作

### 3、标记-复制算法

它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，复制的代价会较小

<img src="https://raw.githubusercontent.com/KKKLxxx/img-host/master/20210909204739534.png" style="zoom:50%;" />

**优点：不存在空间碎片问题**

**缺点：浪费了一半空间**

**优化**：

由于98%的新生代对象会在第一次垃圾回收时消亡，所以并不需要将内存对半分。虚拟机会将**新生代**分为**一块较大的Eden**空间和**两块较小的Survivor**空间，Eden和Survivor大小默认比例为8:1，每次分配内存只使用Eden和其中一块Survivor。发生垃圾回收时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间

由于无法保证每次回收都只有不多于10%的对象存活，所以当Survivor空间不足以容纳一次`Minor GC`之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行**分配担保**

### 4、标记-整理算法

就是标记后将可存活的对象统一移动至内存的一端，然后直接清理边界之外的内存

<img src="https://raw.githubusercontent.com/KKKLxxx/img-host/master/20210909210244891.png" style="zoom:50%;" />

**优点：没有空间碎片化问题**

**缺点：更加耗时，效率较低**

### 5、总结

**新生代存活率低，复制成本低，适合标记-复制算法**

**老年代存活率高，且没有额外空间进行分配担保，所以适合标记-清除/整理算法**

## 五、垃圾收集器

衡量垃圾收集器的三项最重要的指标是：**内存占用**、**吞吐量**和**延迟**，三者共同构成了一个“不可能三角"。垃圾收集器的种类非常多，可以用一张图表示

<img src="https://raw.githubusercontent.com/KKKLxxx/img-host/master/20210909212734567.png" style="zoom: 67%;" />

如果两个收集器之间存在连线，就说明它们可以搭配使用。图中收集器所处的区域，则表示它是属于新生代收集器或是老年代收集器（G1是整堆收集器）。但因篇幅有限，本文仅介绍CMS和G1两种比较重要的收集器

### 1、Stop The World（STW）问题

在介绍之前，先补充一些关于STW问题的知识。JVM在**标记**和**整理**这两个过程，通常需要暂停用户线程才能进行。因为标记时，如果不暂停用户线程，会导致一些标记变动；整理时，需要移动对象空间并更新对象引用，所以一定要暂停用户线程

### 2、CMS（Concurrent Mark Sweep）

CMS收集器是一种**以获取最短回收停顿时间为目标**的收集器。从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于标记-清除算法实现的

> CMS的运作工程分为4个步骤：
>
> 1、**初始标记**：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快
>
> 2、**并发标记**：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行
>
> 3、**重新标记**：修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短
>
> 4、**并发清除**：清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的
>
> 由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一 起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的
>

**优点：并发收集、低停顿**

**缺点**：

1、**对处理器资源非常敏感**：在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的计算能力）而导致应用程序变慢，降低总吞吐量。CMS默认启动的回收线程数是（处理器核心数量+3）/4，也就是说，如果处理器核心数在四个或以上，并发回收时垃圾收集线程只占用不超过25%的处理器运算资源，并且会随着处理器核心数量的增加而下降。但是当处理器核心数量不足四个时，CMS对用户程序的影响就可能变得很大

2、**无法处理“浮动垃圾”**：在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为“浮动垃圾”

3、**需要给用户线程预留足够的内存**：同样也是由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集，导致收集效率有一定的下降

4、**空间碎片问题**：由于CMS是基于标记-清除算法的，固然就会有碎片化问题

**其中2、4两点可能会导致完全STW的Full GC**

### 3、G1（Garbage First）

**整堆收集原理**：**G1把连续的Java堆划分为多个大小相等的独立区域（Region）**，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理。Region中还有一类特殊的**Humongous**区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待

<img src="https://raw.githubusercontent.com/KKKLxxx/img-host/master/20210909221313643.png" style="zoom:50%;" />

**可预测的停顿时间模型**：停顿时间模型的意思是能够支持指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标。G1收集器之所以能建立可预测的停顿时间模型，是因为**G1收集器可以跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间，优先处理回收价值收益最大的那些Region**，这也就是“Garbage First”名字的由来。这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率

**解决跨Region引用问题**：类似跨代引用问题，将Java堆分成多个独立Region后，也会出现跨Region引用问题。同样要**通过记忆集（Remember Set）来维护引用关系**，但是相比于跨代引用更加复杂，因为每个Region都需要维护各自的记忆集

**解决并发标记阶段收集线程与用户线程互不干扰地运行的问题**：首先要解决的是**用户线程改变对象引用关系时，必须保证其不能打破原本的对象图结构，导致标记结果出现错误**：**CMS收集器采用增量更新算法实现，而G1收集器则是通过原始快照（SATB）算法来实现的**。此外，垃圾收集对用户线程的影响还体现在**回收过程中新创建对象的内存分配**上，程序要继续运行就肯定会持续有新对象被创建，**G1为每一个Region设计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配**，并发回收时新分配的对象地址都必须要在这两个指针位置以上。G1收集器默认在这个地址以上的对象是被隐式标记过的，即默认它们是存活的，不纳入回收范围

> G1收集器的运作过程大致可划分为以下四个步骤：
>
> 1、**初始标记**：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短
>
> 2、**并发标记**：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象
>
> 3、**最终标记**：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录
>
> 4、**筛选回收**：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的
>
> 从上述阶段的描述可以看出，G1收集器除了并发标记外，其余阶段也是要完全暂停用户线程的，换言之，它并非纯粹地追求低延迟，官方给它设定的目标是**在延迟可控的情况下获得尽可能高的吞吐量**
>

### 4、CMS与G1对比

1、CMS追求低延迟（STW时间较少但会使用户线程运行效率降低），G1追求高吞吐量（STW时间较长但追求总体吞吐量的最大化）

2、CMS是老年代收集器，G1是整堆收集器

3、CMS在低内存（6GB以下）时表现好，G1在高内存时表现好，因为G1的记忆集庞大复杂，需要耗费大量内存空间

4、CMS采用标记-清除算法，G1从整体来看是基于“标记-整理”算法实现的收集器，但从局部（两个Region之间）上看又是基于“标记-复制”算法实现

### 5、其他垃圾收集器

其实还有更加高端的垃圾收集器，如Shenandoah和ZGC，被官方命名为“低延迟垃圾收集器”，但这两款目前仍处于实验状态

### 6、JDK8默认垃圾收集器

可以在`cmd`中通过`java -XX:+PrintCommandLineFlags -version`指令查看

得到的结果是`UseParallelGC`

所以在JDK8中的垃圾收集器是`Parallel Scavenge`（新生代）+`Serial Old`（老年代）的组合

## 六、其他问题

### 1、对象进入老年代的时机

1、**分配担保机制**

当使用标记-复制算法清理时，如果survivor区放不下存活的对象，就会通过分配担保机制让对象进入老年代

2、**大对象**

一些大对象，比如数组，会直接进入老年代

3、**年龄判断**

当一个对象经历过一定次数的minor gc后仍然存活，那么就可以进入老年代（默认15次）

动态年龄判断：如果一批对象的内存占用大于survivor区的50%，那么年龄大于这批对象的对象就可以进入老年代（批的分类标准可以是年龄）

### 2、如何判断一个常量是废弃常量

假如在字符串常量池中存在字符串`abc`，如果当前没有任何`String`对象引用该字符串常量的话，就说明常量`abc`就是废弃常量，如果这时发生内存回收的话而且有必要的话，`abc`就会被系统清理出常量池了

### 3、如何判断一个类是无用的类

类需要同时满足下面3个条件才能算是 **“无用的类”** ：

- 该类对应的`Class`对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

- 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例
- 加载该类的`ClassLoader`已经被回收

虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收